<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gridap.Arrays · InplaceArrays</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InplaceArrays</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../Gridap/">Gridap</a></li><li><a class="toctext" href="../Helpers/">Gridap.Helpers</a></li><li><a class="toctext" href="../Inference/">Gridap.Inference</a></li><li class="current"><a class="toctext" href>Gridap.Arrays</a><ul class="internal"><li><a class="toctext" href="#Extended-AbstractArray-interface-1">Extended AbstractArray interface</a></li><li><a class="toctext" href="#Creting-lazy-operation-trees-1">Creting lazy operation trees</a></li><li><a class="toctext" href="#Concrete-array-implementations-1">Concrete array implementations</a></li></ul></li><li><a class="toctext" href="../Fields/">Gridap.Fields</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Gridap.Arrays</a></li></ul><a class="edit-page" href="https://github.com/fverdugo/InplaceArrays.jl/blob/master/docs/src/Arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Gridap.Arrays</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Gridap.Arrays-1" href="#Gridap.Arrays-1">Gridap.Arrays</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays" href="#InplaceArrays.Arrays"><code>InplaceArrays.Arrays</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This module provides:</p><ul><li>An extension of the <code>AbstractArray</code> interface in order to properly deal with mutable caches.</li><li>A mechanism to generate lazy arrays resulting from operations between arrays.</li><li>A collection of concrete implementations of <code>AbstractArray</code>.</li></ul><p>The exported names in this module are:</p><ul><li><a href="#InplaceArrays.Arrays.CachedArray"><code>CachedArray</code></a></li><li><a href="#InplaceArrays.Arrays.CachedMatrix"><code>CachedMatrix</code></a></li><li><a href="#InplaceArrays.Arrays.CachedVector"><code>CachedVector</code></a></li><li><a href="#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply</code></a></li><li><a href="#InplaceArrays.Arrays.apply_all"><code>apply_all</code></a></li><li><a href="#InplaceArrays.Arrays.apply_kernel"><code>apply_kernel</code></a></li><li><a href="#InplaceArrays.Arrays.apply_kernel!"><code>apply_kernel!</code></a></li><li><a href="#InplaceArrays.Arrays.apply_kernels!"><code>apply_kernels!</code></a></li><li><a href="#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}"><code>array_cache</code></a></li><li><a href="#InplaceArrays.Arrays.array_caches"><code>array_caches</code></a></li><li><a href="#InplaceArrays.Arrays.bcast"><code>bcast</code></a></li><li><a href="#InplaceArrays.Arrays.contract"><code>contract</code></a></li><li><a href="#InplaceArrays.Arrays.elem"><code>elem</code></a></li><li><a href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a></li><li><a href="#InplaceArrays.Arrays.getitems!"><code>getitems!</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_cache"><code>kernel_cache</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_caches"><code>kernel_caches</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_return_type"><code>kernel_return_type</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_return_types"><code>kernel_return_types</code></a></li><li><a href="#InplaceArrays.Arrays.setsize!"><code>setsize!</code></a></li><li><a href="#InplaceArrays.Arrays.test_array"><code>test_array</code></a></li><li><a href="#InplaceArrays.Arrays.test_kernel"><code>test_kernel</code></a></li><li><a href="#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}"><code>testitem</code></a></li><li><a href="#InplaceArrays.Arrays.testitems"><code>testitems</code></a></li><li><a href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>uses_hash</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Arrays.jl#L1-L10">source</a></section><h2><a class="nav-anchor" id="Extended-AbstractArray-interface-1" href="#Extended-AbstractArray-interface-1">Extended AbstractArray interface</a></h2><p>New methods added that can be overload by new types:</p><ul><li><a href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!(cache,a::AbstractArray,i...)</code></a></li><li><a href="#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}"><code>array_cache(a::AbstractArray)</code></a></li><li><a href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>uses_hash(::Type{&lt;:AbstractArray})</code></a></li><li><a href="#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}"><code>testitem(a::AbstractArray)</code></a></li></ul><p>The interface can be tested with the following function</p><ul><li><a href="#InplaceArrays.Arrays.test_array"><code>test_array</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}" href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>InplaceArrays.Arrays.getindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getindex!(cache::Any, a::AbstractArray, i::Vararg{Any,N} where N) -&gt; Any
</code></pre><p>Returns the item of the array <code>a</code> associated with index <code>i</code> by (possibly) using the scratch data passed in the <code>cache</code> object.</p><p>It defaults to</p><pre><code class="language-none">getindex!(cache,a::AbstractArray,i...) = a[i...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.getitems!" href="#InplaceArrays.Arrays.getitems!"><code>InplaceArrays.Arrays.getitems!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getitems!(cf, a, i)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}" href="#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}"><code>InplaceArrays.Arrays.array_cache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array_cache(a::AbstractArray) -&gt; Any
</code></pre><p>Returns a cache object to be used in the <a href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a> function. It defaults to </p><pre><code class="language-none">array_cache(a::T) where T = nothing</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(false)</code>, and </p><pre><code class="language-none">function array_cache(a::T) where T
  hash = Dict{UInt,Any}()
  array_cache(hash,a)
end</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(true)</code>, see the <a href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>uses_hash</code></a> function. In the later case, the type <code>T</code> should implement the following signature:</p><pre><code class="language-none">array_cache(hash::Dict,a::AbstractArray)</code></pre><p>where we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object <code>a</code> has already build a cache and re-use it as follows</p><pre><code class="language-none">id = objectid(a)
if haskey(hash,id)
  cache = hash[id] # Reuse cache
else
  cache = ... # Build a new cache depending on your needs
  hash[id] = cache # Register the cache in the hash table
end</code></pre><p>This mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.array_caches" href="#InplaceArrays.Arrays.array_caches"><code>InplaceArrays.Arrays.array_caches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">array_caches(a, b)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}" href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>InplaceArrays.Arrays.uses_hash</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">uses_hash(::Type{&lt;:AbstractArray})</code></pre><p>This function is used to specify if the type <code>T</code> uses the hash-based mechanism to reuse caches.  It should return either <code>Val(true)</code> or <code>Val(false)</code>. It defaults to</p><pre><code class="language-none">uses_hash(::Type{&lt;:AbstractArray}) = Val(false)</code></pre><p>Once this function is defined for the type <code>T</code> it can also be called on instances of <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L69-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.testitem-Tuple{AbstractArray}" href="#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}"><code>InplaceArrays.Arrays.testitem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns an arbitrary instance of <code>eltype(a)</code>. The default returned value is the first entry in the array if <code>length(a)&gt;0</code> and <code>testvalue(eltype(a))</code> if <code>length(a)==0</code> See the <a href="../Inference/#InplaceArrays.Inference.testvalue"><code>testvalue</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.testitems" href="#InplaceArrays.Arrays.testitems"><code>InplaceArrays.Arrays.testitems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">testitems(b::AbstractArray...) -&gt; Tuple</code></pre><p>Returns a tuple with the result of <code>testitem</code> applied to each of the arrays in <code>b</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L138-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.test_array" href="#InplaceArrays.Arrays.test_array"><code>InplaceArrays.Arrays.test_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">test_array(
  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}</code></pre><p>Checks if the entries in <code>a</code> and <code>b</code> are equal using the comparison function <code>cmp</code>. It also stresses the new methods added to the <code>AbstractArray</code> interface interface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Interface.jl#L107-L113">source</a></section><h2><a class="nav-anchor" id="Creting-lazy-operation-trees-1" href="#Creting-lazy-operation-trees-1">Creting lazy operation trees</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}" href="#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>InplaceArrays.Arrays.apply</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply(f,a::AbstractArray...) -&gt; AbstractArray</code></pre><p>Applies the kernel <code>f</code> to all entries in the arrays in <code>a</code>.</p><p>The resulting array has the same entries as the one obtained with (see function <a href="#InplaceArrays.Arrays.apply_kernel"><code>apply_kernel</code></a>):</p><pre><code class="language-none">map( (x...)-&gt;apply_kernel(f,x...), a...)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.Arrays
a = apply(+,[1,2,3],[4,5,6])
println(a)
# output
[5, 7, 9]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Apply.jl#L2-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}" href="#InplaceArrays.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}"><code>InplaceArrays.Arrays.apply</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply(f::AbstractArray,a::AbstractArray...) -&gt; AbstractArray</code></pre><p>Applies the kernels in the array of kernels <code>f</code> to the entries in the arrays in <code>a</code>.</p><p>The resulting array has the same entries as the one obtained with (see function <a href="#InplaceArrays.Arrays.apply_kernel"><code>apply_kernel</code></a>):</p><pre><code class="language-none">map( apply_kernel, f, a...)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.Arrays
a = apply([+,-,mod],[1,2,3],[4,5,6])
println(a)
# output
[5, -3, 3]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Apply.jl#L27-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_all" href="#InplaceArrays.Arrays.apply_all"><code>InplaceArrays.Arrays.apply_all</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_all(f::Tuple,a::AbstractArray...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Apply.jl#L57-L59">source</a></section><h3><a class="nav-anchor" id="Operation-kernels-1" href="#Operation-kernels-1">Operation kernels</a></h3><p>The <a href="#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply</code></a> function provides a mechanism to construct lazy arrays obtained by applying some operations to other arrays. The operations are represented by objects (referred to as <em>kernels</em>). We rely in duck typing here. There is not an abstract type representing a kernel. Any type is referred to as a <em>kernel</em> if it implements the following interface:</p><ul><li><a href="#InplaceArrays.Arrays.apply_kernel!"><code>apply_kernel!(cache,k,x...)</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_cache"><code>kernel_cache(k,x...)</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_return_type"><code>kernel_return_type(k,x...)</code></a></li></ul><p>The kernel interface can be tested with the <a href="#InplaceArrays.Arrays.test_kernel"><code>test_kernel</code></a> function.</p><p>We provide some default (obvious) implementations of this interface so that <code>Function</code>, <code>Number</code>, and <code>AbstractArray</code> objects behave like kernels.</p><pre><code class="language-julia-repl">julia&gt; using InplaceArrays.Arrays

julia&gt; cache = kernel_cache(+,0,0)

julia&gt; apply_kernel!(cache,+,1,2)
3

julia&gt; apply_kernel!(cache,+,-1,10)
9</code></pre><p><code>Number</code> and <code>AbstractArray</code> objects behave like &quot;constant&quot; kernels.</p><pre><code class="language-julia-repl">julia&gt; using InplaceArrays.Arrays

julia&gt; a = 2.0
2.0

julia&gt; cache = kernel_cache(a,0)

julia&gt; apply_kernel!(cache,a,1)
2.0

julia&gt; apply_kernel!(cache,a,2)
2.0

julia&gt; apply_kernel!(cache,a,3)
2.0</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_kernel!" href="#InplaceArrays.Arrays.apply_kernel!"><code>InplaceArrays.Arrays.apply_kernel!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_kernel!(cache, f, x)
</code></pre><p>applies the kernel <code>f</code> at the arguments <code>x...</code> using the scratch data provided in the given <code>cache</code> object. The <code>cache</code> object is built with the <a href="#InplaceArrays.Arrays.kernel_cache"><code>kernel_cache</code></a> function using arguments of the same type as in <code>x...</code> In general, the returned value <code>y</code> can share some part of its state with the <code>cache</code> object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various <code>cache</code> objects (e.g., one cache per thread).</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_cache" href="#InplaceArrays.Arrays.kernel_cache"><code>InplaceArrays.Arrays.kernel_cache</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kernel_cache(f, x)
</code></pre><p>Returns the <code>cache</code> needed to apply kernel <code>f</code> with arguments of the same type as the objects in <code>x...</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_return_type" href="#InplaceArrays.Arrays.kernel_return_type"><code>InplaceArrays.Arrays.kernel_return_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kernel_return_type(f, x)
</code></pre><p>Returns the type of the result of calling kernel <code>f</code> with arguments of the types of the objects <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.test_kernel" href="#InplaceArrays.Arrays.test_kernel"><code>InplaceArrays.Arrays.test_kernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">test_kernel(f, x, y)
test_kernel(f, x, y, cmp)
</code></pre><p>Function used to test if the kernel <code>f</code> has been implemented correctly. <code>f</code> is a kernel object, <code>x</code> is the input of the kernel, and <code>y</code> is the expected result. Function <code>cmp</code> is used to compare the computed result with the expected one. The checks are done with the <code>@test</code> macro.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L40">source</a></section><h3><a class="nav-anchor" id="Build-in-kernels-1" href="#Build-in-kernels-1">Build-in kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.bcast" href="#InplaceArrays.Arrays.bcast"><code>InplaceArrays.Arrays.bcast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bcast(f::Function)</code></pre><p>Returns a kernel object that represents the &quot;boradcasted&quot; version of the given function <code>f</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L177-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.elem" href="#InplaceArrays.Arrays.elem"><code>InplaceArrays.Arrays.elem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">elem(f::Function)</code></pre><p>Returns a kernel that represents the element-wise version of the binary or unary operation <code>f</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L224-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.contract" href="#InplaceArrays.Arrays.contract"><code>InplaceArrays.Arrays.contract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">contract(f::Function)</code></pre><p>Like the dot product between to vectors, but using operation <code>f</code> instead of <code>*</code> between components.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.Arrays
k = contract(-)
apply_kernel(k,[1,2],[2,4]) # Equivalent to (1-2) + (2-4)
# output
-3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L348-L363">source</a></section><h3><a class="nav-anchor" id="Other-functions-acting-on-kernels-1" href="#Other-functions-acting-on-kernels-1">Other functions acting on kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_kernel" href="#InplaceArrays.Arrays.apply_kernel"><code>InplaceArrays.Arrays.apply_kernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_kernel(f,x...)</code></pre><p>apply the fuctor <code>f</code> at the arguments <code>x...</code> by creating a temporary cache internally. This functions is equivalent to</p><pre><code class="language-jl">cache = kernel_cache(f,x...)
apply_kernel!(cache,f,x...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L63-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_kernels!" href="#InplaceArrays.Arrays.apply_kernels!"><code>InplaceArrays.Arrays.apply_kernels!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_kernels!(caches::Tuple,fs::Tuple,x...) -&gt; Tuple</code></pre><p>Applies the kernels in the tuple <code>fs</code> at the arguments <code>x...</code> by using the corresponding cache objects in the tuple <code>caches</code>. The result is also a tuple containing the result for each kernel in <code>fs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L102-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_caches" href="#InplaceArrays.Arrays.kernel_caches"><code>InplaceArrays.Arrays.kernel_caches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kernel_caches(fs::Tuple,x...) -&gt; Tuple</code></pre><p>Returns a tuple with the cache corresponding to each kernel in <code>fs</code> for the arguments <code>x...</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L81-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_return_types" href="#InplaceArrays.Arrays.kernel_return_types"><code>InplaceArrays.Arrays.kernel_return_types</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kernel_return_types(f, Ts)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/Kernels.jl#L130">source</a></section><h2><a class="nav-anchor" id="Concrete-array-implementations-1" href="#Concrete-array-implementations-1">Concrete array implementations</a></h2><h3><a class="nav-anchor" id="CachedArray-1" href="#CachedArray-1">CachedArray</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedArray" href="#InplaceArrays.Arrays.CachedArray"><code>InplaceArrays.Arrays.CachedArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct CachedArray{T, N, A&lt;:AbstractArray{T,N}} &lt;: AbstractArray{T,N}</code></pre><p>Type providing a re-sizable array that only allocates memory when the underlying buffer needs to grow.</p><p>The size of a <code>CachedArray</code> is changed via the <a href="#InplaceArrays.Arrays.setsize!"><code>setsize!</code></a> function.</p><p>A <code>CachedArray</code> can be build with the constructors</p><ul><li><a href="#InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}"><code>CachedArray(a::AbstractArray)</code></a></li><li><a href="#InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}"><code>CachedArray(T,N)</code></a></li></ul><pre><code class="language-julia">using InplaceArrays.Arrays
# Create an empty CachedArray
a = CachedArray(Float64,2)
# Resize to new shape (2,3)
setsize!(a,(2,3))
size(a)
# output
(2, 3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/CachedArrays.jl#L2">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}" href="#InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}"><code>InplaceArrays.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CachedArray(a)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/CachedArrays.jl#L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}" href="#InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}"><code>InplaceArrays.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CachedArray(T, N)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/CachedArrays.jl#L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.setsize!" href="#InplaceArrays.Arrays.setsize!"><code>InplaceArrays.Arrays.setsize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setsize!(a, s)
</code></pre><p>Changes the size of the <code>CachedArray</code> <code>a</code> to the size described the the tuple <code>s</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>After calling <code>setsize!</code>, the array can store uninitialized values.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/CachedArrays.jl#L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedMatrix" href="#InplaceArrays.Arrays.CachedMatrix"><code>InplaceArrays.Arrays.CachedMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">const CachedMatrix{T,A} = CachedArray{T,2,A}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/CachedArrays.jl#L30-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedVector" href="#InplaceArrays.Arrays.CachedVector"><code>InplaceArrays.Arrays.CachedVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">const CachedVector{T,A} = CachedArray{T,1,A}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4c9718d7ca50d6f6e9b4928415fdc057dab64cb7/src/Arrays/CachedArrays.jl#L35-L37">source</a></section><footer><hr/><a class="previous" href="../Inference/"><span class="direction">Previous</span><span class="title">Gridap.Inference</span></a><a class="next" href="../Fields/"><span class="direction">Next</span><span class="title">Gridap.Fields</span></a></footer></article></body></html>
