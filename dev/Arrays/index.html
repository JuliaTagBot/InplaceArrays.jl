<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gridap.Arrays · InplaceArrays</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InplaceArrays</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../Gridap/">Gridap</a></li><li><a class="toctext" href="../Helpers/">Gridap.Helpers</a></li><li><a class="toctext" href="../Inference/">Gridap.Inference</a></li><li><a class="toctext" href="../TensorValues/">Gridap.TensorValues</a></li><li class="current"><a class="toctext" href>Gridap.Arrays</a><ul class="internal"><li><a class="toctext" href="#Extended-AbstractArray-interface-1">Extended AbstractArray interface</a></li><li><a class="toctext" href="#Working-with-several-arrays-at-once-1">Working with several arrays at once</a></li><li><a class="toctext" href="#Creting-lazy-operation-trees-1">Creting lazy operation trees</a></li><li><a class="toctext" href="#Concrete-array-implementations-1">Concrete array implementations</a></li></ul></li><li><a class="toctext" href="../Fields/">Gridap.Fields</a></li><li><a class="toctext" href="../Polynomials/">Gridap.Polynomials</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Gridap.Arrays</a></li></ul><a class="edit-page" href="https://github.com/fverdugo/InplaceArrays.jl/blob/master/docs/src/Arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Gridap.Arrays</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Gridap.Arrays-1" href="#Gridap.Arrays-1">Gridap.Arrays</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays" href="#InplaceArrays.Arrays"><code>InplaceArrays.Arrays</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This module provides:</p><ul><li>An extension of the <code>AbstractArray</code> interface in order to properly deal with mutable caches.</li><li>A mechanism to generate lazy arrays resulting from operations between arrays.</li><li>A collection of concrete implementations of <code>AbstractArray</code>.</li></ul><p>The exported names in this module are:</p><ul><li><a href="#InplaceArrays.Arrays.CachedArray"><code>CachedArray</code></a></li><li><a href="#InplaceArrays.Arrays.CachedMatrix"><code>CachedMatrix</code></a></li><li><a href="#InplaceArrays.Arrays.CachedVector"><code>CachedVector</code></a></li><li><a href="#InplaceArrays.Arrays.Kernel"><code>Kernel</code></a></li><li><a href="#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply</code></a></li><li><a href="#InplaceArrays.Arrays.apply_all"><code>apply_all</code></a></li><li><a href="#InplaceArrays.Arrays.apply_kernel"><code>apply_kernel</code></a></li><li><a href="#InplaceArrays.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>apply_kernel!</code></a></li><li><a href="#InplaceArrays.Arrays.apply_kernels!"><code>apply_kernels!</code></a></li><li><a href="#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}"><code>array_cache</code></a></li><li><a href="#InplaceArrays.Arrays.array_caches"><code>array_caches</code></a></li><li><a href="#InplaceArrays.Arrays.bcast"><code>bcast</code></a></li><li><a href="#InplaceArrays.Arrays.contract"><code>contract</code></a></li><li><a href="#InplaceArrays.Arrays.elem"><code>elem</code></a></li><li><a href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a></li><li><a href="#InplaceArrays.Arrays.getitems!"><code>getitems!</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_cache</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_caches"><code>kernel_caches</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_return_type</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_return_types"><code>kernel_return_types</code></a></li><li><a href="#InplaceArrays.Arrays.setsize!"><code>setsize!</code></a></li><li><a href="#InplaceArrays.Arrays.test_array"><code>test_array</code></a></li><li><a href="#InplaceArrays.Arrays.test_kernel"><code>test_kernel</code></a></li><li><a href="#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}"><code>testitem</code></a></li><li><a href="#InplaceArrays.Arrays.testitems"><code>testitems</code></a></li><li><a href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>uses_hash</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Arrays.jl#L1-L10">source</a></section><h2><a class="nav-anchor" id="Extended-AbstractArray-interface-1" href="#Extended-AbstractArray-interface-1">Extended AbstractArray interface</a></h2><p>When implementing new array types, it can be needed some scratch data (e.g., allocating the output), when recovering an item from an array (typically if the array elements are non-isbits objects). To circumvent this, the user could provide the scratch data needed when getting an item. However, the Julia array interface does not support this approach. When calling <code>a[i]</code>, in order to get the element with index <code>i</code> in array <code>a</code>, there is no extra argument for the scratch data. In order to solve this problem, we add new methods to the <code>AbstractArray</code> interface of Julia. We provide default implementations to the new methods, so that any <code>AbstractArray</code> can be used with the extended interface. New array implementations can overload these default implementations to improve performance. The most important among the new methods is <a href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a>, which allows to recover an item in the array by passing some scratch data.</p><p>The new methods are:</p><ul><li><a href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!(cache,a::AbstractArray,i...)</code></a></li><li><a href="#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}"><code>array_cache(a::AbstractArray)</code></a></li><li><a href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>uses_hash(::Type{&lt;:AbstractArray})</code></a></li><li><a href="#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}"><code>testitem(a::AbstractArray)</code></a></li></ul><p>These methods can be stressed with the following function</p><ul><li><a href="#InplaceArrays.Arrays.test_array"><code>test_array</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}" href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>InplaceArrays.Arrays.getindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getindex!(cache,a::AbstractArray,i...)</code></pre><p>Returns the item of the array <code>a</code> associated with index <code>i</code> by (possibly) using the scratch data passed in the <code>cache</code> object.</p><p>It defaults to</p><pre><code class="language-none">getindex!(cache,a::AbstractArray,i...) = a[i...]</code></pre><p><strong>Examples</strong></p><p>Iterating over an array using the <code>getindex!</code> function</p><pre><code class="language-julia">using InplaceArrays.Arrays

a = collect(10:15)

cache = array_cache(a)
for i in eachindex(a)
  ai = getindex!(cache,a,i)
  println(&quot;$i -&gt; $ai&quot;)
end

# output
1 -&gt; 10
2 -&gt; 11
3 -&gt; 12
4 -&gt; 13
5 -&gt; 14
6 -&gt; 15</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L1-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}" href="#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}"><code>InplaceArrays.Arrays.array_cache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array_cache(a::AbstractArray)</code></pre><p>Returns a cache object to be used in the <a href="#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}"><code>getindex!</code></a> function. It defaults to </p><pre><code class="language-none">array_cache(a::T) where T = nothing</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(false)</code>, and </p><pre><code class="language-none">function array_cache(a::T) where T
  hash = Dict{UInt,Any}()
  array_cache(hash,a)
end</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(true)</code>, see the <a href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>uses_hash</code></a> function. In the later case, the type <code>T</code> should implement the following signature:</p><pre><code class="language-none">array_cache(hash::Dict,a::AbstractArray)</code></pre><p>where we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object <code>a</code> has already build a cache and re-use it as follows</p><pre><code class="language-none">id = objectid(a)
if haskey(hash,id)
  cache = hash[id] # Reuse cache
else
  cache = ... # Build a new cache depending on your needs
  hash[id] = cache # Register the cache in the hash table
end</code></pre><p>This mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L38-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}" href="#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3&lt;:AbstractArray}"><code>InplaceArrays.Arrays.uses_hash</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">uses_hash(::Type{&lt;:AbstractArray})</code></pre><p>This function is used to specify if the type <code>T</code> uses the hash-based mechanism to reuse caches.  It should return either <code>Val(true)</code> or <code>Val(false)</code>. It defaults to</p><pre><code class="language-none">uses_hash(::Type{&lt;:AbstractArray}) = Val(false)</code></pre><p>Once this function is defined for the type <code>T</code> it can also be called on instances of <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L93-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.testitem-Tuple{AbstractArray}" href="#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}"><code>InplaceArrays.Arrays.testitem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns an arbitrary instance of <code>eltype(a)</code>. The default returned value is the first entry in the array if <code>length(a)&gt;0</code> and <code>testvalue(eltype(a))</code> if <code>length(a)==0</code> See the <a href="../Inference/#InplaceArrays.Inference.testvalue"><code>testvalue</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.Arrays

a = collect(3:10)
ai = testitem(a)

b = Int[]
bi = testitem(b)

(ai, bi)

# output
(3, 0)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.test_array" href="#InplaceArrays.Arrays.test_array"><code>InplaceArrays.Arrays.test_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">test_array(
  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}</code></pre><p>Checks if the entries in <code>a</code> and <code>b</code> are equal using the comparison function <code>cmp</code>. It also stresses the new methods added to the <code>AbstractArray</code> interface interface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L150-L156">source</a></section><h2><a class="nav-anchor" id="Working-with-several-arrays-at-once-1" href="#Working-with-several-arrays-at-once-1">Working with several arrays at once</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.getitems!" href="#InplaceArrays.Arrays.getitems!"><code>InplaceArrays.Arrays.getitems!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getitems!(c::Tuple,a::Tuple,i...) -&gt; Tuple</code></pre><p>Extracts the <code>i</code>-th entry of all arrays in the tuple <code>a</code> using the caches in the tuple <code>c</code>. The results is a tuple containing each one of the extracted entries.</p><p><strong>Example</strong></p><p>Iterating over three different arrays simultaneously using <code>getitems!</code></p><pre><code class="language-julia">using InplaceArrays.Arrays

a = collect(0:5)
b = collect(10:15)
c = collect(20:25)

caches = array_caches(a,b,c)
for i in eachindex(a)
   s = getitems!(caches,(a,b,c),i)
   println(&quot;$i -&gt; $s&quot;)
end

# output
1 -&gt; (0, 10, 20)
2 -&gt; (1, 11, 21)
3 -&gt; (2, 12, 22)
4 -&gt; (3, 13, 23)
5 -&gt; (4, 14, 24)
6 -&gt; (5, 15, 25)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L236-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.array_caches" href="#InplaceArrays.Arrays.array_caches"><code>InplaceArrays.Arrays.array_caches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">array_caches(a::AbstractArray...) -&gt; Tuple</code></pre><p>Returns a tuple with the cache of each array in <code>a</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L215-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.testitems" href="#InplaceArrays.Arrays.testitems"><code>InplaceArrays.Arrays.testitems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">testitems(b::AbstractArray...) -&gt; Tuple</code></pre><p>Returns a tuple with the result of <code>testitem</code> applied to each of the arrays in <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.Arrays

a = collect(3:10)
b = Int[]
c = Float64[]
d = ones(10)

testitems(a,b,c,d)

# output
(3, 0, 0.0, 1.0)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Interface.jl#L181-L203">source</a></section><h2><a class="nav-anchor" id="Creting-lazy-operation-trees-1" href="#Creting-lazy-operation-trees-1">Creting lazy operation trees</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}" href="#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>InplaceArrays.Arrays.apply</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply(f,a::AbstractArray...) -&gt; AbstractArray</code></pre><p>Applies the kernel <code>f</code> to the entries of the arrays in <code>a</code> (see the definition of <a href="#InplaceArrays.Arrays.Kernel"><code>Kernel</code></a>).</p><p>The resulting array <code>r</code> is such that <code>r[i]</code> equals to <code>apply_kernel(f,ai...)</code> where <code>ai</code> is the tuple containing the <code>i</code>-th entry of the arrays in <code>a</code> (see function <a href="#InplaceArrays.Arrays.apply_kernel"><code>apply_kernel</code></a> for more details). In other words, the resulting array is numerically equivalent to:</p><pre><code class="language-none">map( (x...)-&gt;apply_kernel(f,x...), a...)</code></pre><p>See the <a href="#InplaceArrays.Arrays.apply_kernel"><code>apply_kernel</code></a> function for details.</p><p><strong>Examples</strong></p><p>Using a function as kernel</p><pre><code class="language-julia">using InplaceArrays.Arrays

a = collect(0:5)
b = collect(10:15)

c = apply(+,a,b)

println(c)

# output
[10, 12, 14, 16, 18, 20]</code></pre><p>Using a user-defined kernel</p><pre><code class="language-julia">using InplaceArrays.Arrays
import InplaceArrays.Arrays: apply_kernel!

a = collect(0:5)
b = collect(10:15)

struct MySum &lt;: Kernel end

apply_kernel!(cache,::MySum,x,y) = x + y

k = MySum()

c = apply(k,a,b)

println(c)

# output
[10, 12, 14, 16, 18, 20]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Apply.jl#L2-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},Any,Vararg{AbstractArray,N} where N}} where T" href="#InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},Any,Vararg{AbstractArray,N} where N}} where T"><code>InplaceArrays.Arrays.apply</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply(::Type{T},f,a::AbstractArray...) where T</code></pre><p>Like <a href="#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply(f,a::AbstractArray...)</code></a>, but the user provides the element type of the resulting array in order to circumvent type inference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Apply.jl#L64-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}" href="#InplaceArrays.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}"><code>InplaceArrays.Arrays.apply</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply(f::AbstractArray,a::AbstractArray...) -&gt; AbstractArray</code></pre><p>Applies the kernels in the array of kernels <code>f</code> to the entries in the arrays in <code>a</code>.</p><p>The resulting array has the same entries as the one obtained with:</p><pre><code class="language-none">map( apply_kernel, f, a...)</code></pre><p>See the <a href="#InplaceArrays.Arrays.apply_kernel"><code>apply_kernel</code></a> function for details.</p><p><strong>Example</strong></p><p>&quot;Evaluating&quot; an array of functions</p><pre><code class="language-julia">using InplaceArrays.Arrays

f = [+,-,max,min]
a = [1,2,3,4]
b = [4,3,2,1]

c = apply(f,a,b)

println(c)

# output
[5, -1, 3, 1]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Apply.jl#L75-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},AbstractArray,Vararg{AbstractArray,N} where N}} where T" href="#InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},AbstractArray,Vararg{AbstractArray,N} where N}} where T"><code>InplaceArrays.Arrays.apply</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply(::Type{T},f::AbstractArray,a::AbstractArray...) where T</code></pre><p>Like <a href="#InplaceArrays.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}"><code>apply(f::AbstractArray,a::AbstractArray...)</code></a>, but the user provides the element type of the resulting array in order to circumvent type inference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Apply.jl#L108-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_all" href="#InplaceArrays.Arrays.apply_all"><code>InplaceArrays.Arrays.apply_all</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_all(f::Tuple,a::AbstractArray...) -&gt; Tuple</code></pre><p>Numerically equivalent to </p><pre><code class="language-none">tuple( ( apply(fi, a...) for fi in f)... )</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.Arrays

a = [1,2,3,4]
b = [4,3,2,1]

c = apply_all( (+,-), a, b)

# Equivalent to
# c = ( apply(+,a,b), apply(-,a,b) )

println(c)

# output
([5, 5, 5, 5], [-3, -1, 1, 3])
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Apply.jl#L118-L144">source</a></section><h3><a class="nav-anchor" id="Operation-kernels-1" href="#Operation-kernels-1">Operation kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.Kernel" href="#InplaceArrays.Arrays.Kernel"><code>InplaceArrays.Arrays.Kernel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type representing the operations to be used in the <a href="#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}"><code>apply</code></a> function.</p><p>Derived types must implement the following method:</p><ul><li><a href="#InplaceArrays.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>apply_kernel!(cache,k,x...)</code></a></li></ul><p>and optionally these ones:</p><ul><li><a href="#InplaceArrays.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_cache(k,x...)</code></a></li><li><a href="#InplaceArrays.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_return_type(k,x...)</code></a></li></ul><p>The kernel interface can be tested with the <a href="#InplaceArrays.Arrays.test_kernel"><code>test_kernel</code></a> function.</p><p>Note that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from <code>Kernel</code>. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from <code>Kernel</code>. For instance, a default implementation is available for <code>Function</code> objects.  However, we recommend that new types inherit from <code>Kernel</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L3-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}" href="#InplaceArrays.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>InplaceArrays.Arrays.apply_kernel!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply_kernel!(cache,f,x...)</code></pre><p>Applies the kernel <code>f</code> at the arguments <code>x...</code> using the scratch data provided in the given <code>cache</code> object. The <code>cache</code> object is built with the <a href="#InplaceArrays.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>kernel_cache</code></a> function using arguments of the same type as in <code>x</code>. In general, the returned value <code>y</code> can share some part of its state with the <code>cache</code> object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various <code>cache</code> objects (e.g., one cache per thread).</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L48-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}" href="#InplaceArrays.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}"><code>InplaceArrays.Arrays.kernel_cache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">kernel_cache(f,x...)</code></pre><p>Returns the <code>cache</code> needed to apply kernel <code>f</code> with arguments of the same type as the objects in <code>x</code>. This function returns <code>nothing</code> by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L39-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}" href="#InplaceArrays.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}"><code>InplaceArrays.Arrays.kernel_return_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">kernel_return_type(f,x...)</code></pre><p>Returns the type of the result of calling kernel <code>f</code> with arguments of the types of the objects <code>x</code>.</p><p>It defaults to <code>typeof(apply_kernel(f,x...))</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L27-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.test_kernel" href="#InplaceArrays.Arrays.test_kernel"><code>InplaceArrays.Arrays.test_kernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">test_kernel(f,x::Tuple,y,cmp=(==))</code></pre><p>Function used to test if the kernel <code>f</code> has been implemented correctly. <code>f</code> is a kernel object, <code>x</code> is a tuple containing the arguments  of the kernel, and <code>y</code> is the expected result. Function <code>cmp</code> is used to compare the computed result with the expected one. The checks are done with the <code>@test</code> macro.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L65-L73">source</a></section><h3><a class="nav-anchor" id="Other-functions-using-kernels-1" href="#Other-functions-using-kernels-1">Other functions using kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_kernel" href="#InplaceArrays.Arrays.apply_kernel"><code>InplaceArrays.Arrays.apply_kernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_kernel(f,x...)</code></pre><p>apply the kernel <code>f</code> at the arguments in <code>x</code> by creating a temporary cache internally. This functions is equivalent to</p><pre><code class="language-jl">cache = kernel_cache(f,x...)
apply_kernel!(cache,f,x...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L88-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.apply_kernels!" href="#InplaceArrays.Arrays.apply_kernels!"><code>InplaceArrays.Arrays.apply_kernels!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_kernels!(caches::Tuple,fs::Tuple,x...) -&gt; Tuple</code></pre><p>Applies the kernels in the tuple <code>fs</code> at the arguments <code>x...</code> by using the corresponding cache objects in the tuple <code>caches</code>. The result is also a tuple containing the result for each kernel in <code>fs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L127-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_caches" href="#InplaceArrays.Arrays.kernel_caches"><code>InplaceArrays.Arrays.kernel_caches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kernel_caches(fs::Tuple,x...) -&gt; Tuple</code></pre><p>Returns a tuple with the cache corresponding to each kernel in <code>fs</code> for the arguments <code>x...</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L106-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.kernel_return_types" href="#InplaceArrays.Arrays.kernel_return_types"><code>InplaceArrays.Arrays.kernel_return_types</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kernel_return_types(f::Tuple,x...) -&gt; Tuple</code></pre><p>Computes the return types of the kernels in <code>f</code> when called with arguments <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L155-L160">source</a></section><h3><a class="nav-anchor" id="Build-in-kernels-1" href="#Build-in-kernels-1">Build-in kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.bcast" href="#InplaceArrays.Arrays.bcast"><code>InplaceArrays.Arrays.bcast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bcast(f::Function)</code></pre><p>Returns a kernel object that represents the &quot;boradcasted&quot; version of the given function <code>f</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L189-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.elem" href="#InplaceArrays.Arrays.elem"><code>InplaceArrays.Arrays.elem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">elem(f::Function)</code></pre><p>Returns a kernel that represents the element-wise version of the operation <code>f</code> It does not broadcast in singleton axes. Thus, allows some performance optimizations with respect to broadcast.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>not needed any more, to be deleted</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L253-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.contract" href="#InplaceArrays.Arrays.contract"><code>InplaceArrays.Arrays.contract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">contract(f::Function)</code></pre><p>Like the dot product between to vectors, but using operation <code>f</code> instead of <code>*</code> between components.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>not needed any more, to be deleted</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.Arrays
k = contract(-)
apply_kernel(k,[1,2],[2,4]) # Equivalent to (1-2) + (2-4)
# output
-3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/Kernels.jl#L403-L421">source</a></section><h2><a class="nav-anchor" id="Concrete-array-implementations-1" href="#Concrete-array-implementations-1">Concrete array implementations</a></h2><h3><a class="nav-anchor" id="CachedArray-1" href="#CachedArray-1">CachedArray</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedArray" href="#InplaceArrays.Arrays.CachedArray"><code>InplaceArrays.Arrays.CachedArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct CachedArray{T, N, A&lt;:AbstractArray{T,N}} &lt;: AbstractArray{T,N}</code></pre><p>Type providing a re-sizable array that only allocates memory when the underlying buffer needs to grow.</p><p>The size of a <code>CachedArray</code> is changed via the <a href="#InplaceArrays.Arrays.setsize!"><code>setsize!</code></a> function.</p><p>A <code>CachedArray</code> can be build with the constructors</p><ul><li><a href="#InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}"><code>CachedArray(a::AbstractArray)</code></a></li><li><a href="#InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}"><code>CachedArray(T,N)</code></a></li></ul><pre><code class="language-julia">using InplaceArrays.Arrays
# Create an empty CachedArray
a = CachedArray(Float64,2)
# Resize to new shape (2,3)
setsize!(a,(2,3))
size(a)
# output
(2, 3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/CachedArrays.jl#L2">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}" href="#InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}"><code>InplaceArrays.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CachedArray(a::AbstractArray)</code></pre><p>Constructs a <code>CachedArray</code> from a given array.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/CachedArrays.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}" href="#InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}"><code>InplaceArrays.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CachedArray(T,N)</code></pre><p>Constructs an empty <code>CachedArray</code> of element type <code>T</code> and <code>N</code> dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/CachedArrays.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.setsize!" href="#InplaceArrays.Arrays.setsize!"><code>InplaceArrays.Arrays.setsize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setsize!(a, s)
</code></pre><p>Changes the size of the <code>CachedArray</code> <code>a</code> to the size described the the tuple <code>s</code>. After calling <code>setsize!</code>, the array can store uninitialized values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/CachedArrays.jl#L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedMatrix" href="#InplaceArrays.Arrays.CachedMatrix"><code>InplaceArrays.Arrays.CachedMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">const CachedMatrix{T,A} = CachedArray{T,2,A}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/CachedArrays.jl#L30-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.CachedVector" href="#InplaceArrays.Arrays.CachedVector"><code>InplaceArrays.Arrays.CachedVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">const CachedVector{T,A} = CachedArray{T,1,A}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/a871674d39f5a07a3952daa22432abfd417c12a0/src/Arrays/CachedArrays.jl#L35-L37">source</a></section><footer><hr/><a class="previous" href="../TensorValues/"><span class="direction">Previous</span><span class="title">Gridap.TensorValues</span></a><a class="next" href="../Fields/"><span class="direction">Next</span><span class="title">Gridap.Fields</span></a></footer></article></body></html>
