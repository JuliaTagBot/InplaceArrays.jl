<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The functor interface · InplaceArrays</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InplaceArrays</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>The functor interface</a><ul class="internal"><li><a class="toctext" href="#Default-implementations-1">Default implementations</a></li><li><a class="toctext" href="#Evaluating-a-functor-without-cache-1">Evaluating a functor without cache</a></li><li><a class="toctext" href="#Working-with-several-functors-at-once-1">Working with several functors at once</a></li><li><a class="toctext" href="#Broadcasting-1">Broadcasting</a></li><li><a class="toctext" href="#Composition-1">Composition</a></li></ul></li><li><a class="toctext" href="../Arrays/">Extended AbstractArray interface</a></li><li><a class="toctext" href="../CellValues/">The CellValue interface</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>The functor interface</a></li></ul><a class="edit-page" href="https://github.com/fverdugo/InplaceArrays.jl/blob/master/docs/src/Functors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The functor interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-Functor-interface-1" href="#The-Functor-interface-1">The Functor interface</a></h1><p>Often, it is needed to implement functions that need some scratch data (e.g., pre-allocating the output). The question is, <em>where to store this data?</em> There are three main answers to this question: 1) store the data in the function object as part of its state, 2) allocate the scratch data each time the operation is performed, and 3) the user allocates and passes the scratch data when needed. Clearly, 1) it is not save if several calls to the operation are using the same scratch data (e.g., multi-threading). 2) is save, but it can be inefficient if the operation is performed at low granularity. 3) is both save and efficient, but requires some extra work by the user.</p><p>In Gridap, we adopt the 3rd option. In order to unify the interfaces of functions using this approach, we introduce the <em>Functor interface</em>. Any type is referred to as a <em>Functor</em> if it implements the following interface. We rely in duck typing here. There is not an abstract type representing a functor.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.evaluate_functor!" href="#InplaceArrays.Functors.evaluate_functor!"><code>InplaceArrays.Functors.evaluate_functor!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">y = evaluate_functor!(cache,f,x...)</code></pre><p>Evaluates the functor <code>f</code> at the arguments <code>x...</code> using the scratch data provided in the given <code>cache</code> object. The <code>cache</code> object is built with the <a href="#InplaceArrays.Functors.functor_cache"><code>functor_cache</code></a> function using arguments of the same type as in <code>x...</code> In general, the returned value <code>y</code> can share some part of its state with the <code>cache</code> object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various <code>cache</code> objects (e.g., one cache per thread).</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4937974e4d0f3039c78c13d0f2691e780ba7518a/src/Functors.jl#L26-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.functor_cache" href="#InplaceArrays.Functors.functor_cache"><code>InplaceArrays.Functors.functor_cache</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cache = functor_cache(f,x...)</code></pre><p>Returns the <code>cache</code> needed to evaluate functor <code>f</code> with arguments of the same type as the objects in <code>x...</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4937974e4d0f3039c78c13d0f2691e780ba7518a/src/Functors.jl#L18-L23">source</a></section><h2><a class="nav-anchor" id="Default-implementations-1" href="#Default-implementations-1">Default implementations</a></h2><p>We provide some default (obvious) implementations of this interface so that <code>Function</code>, <code>Number</code>, and <code>AbstractArray</code> objects behave like functors.</p><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>Calling the <code>+</code> function via the functor interface.</p><pre><code class="language-julia-repl">julia&gt; cache = functor_cache(+,0,0)

julia&gt; evaluate_functor!(cache,+,1,2)
3

julia&gt; evaluate_functor!(cache,+,-1,10)
9</code></pre><p><code>Number</code> and <code>AbstractArray</code> objects behave like &quot;constant&quot; functors.</p><pre><code class="language-julia-repl">julia&gt; a = 2.0
2.0

julia&gt; cache = functor_cache(a,0)

julia&gt; evaluate_functor!(cache,a,1)
2.0

julia&gt; evaluate_functor!(cache,a,2)
2.0

julia&gt; evaluate_functor!(cache,a,3)
2.0</code></pre><h2><a class="nav-anchor" id="Evaluating-a-functor-without-cache-1" href="#Evaluating-a-functor-without-cache-1">Evaluating a functor without cache</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.evaluate_functor" href="#InplaceArrays.Functors.evaluate_functor"><code>InplaceArrays.Functors.evaluate_functor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evaluate_functor(f,x...)</code></pre><p>Evaluate the fuctor <code>f</code> at the arguments <code>x...</code> by creating a temporary cache internally. This functions is equivalent to</p><pre><code class="language-jl">cache = functor_cache(f,x...)
evaluate_functor!(cache,f,x...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4937974e4d0f3039c78c13d0f2691e780ba7518a/src/Functors.jl#L39-L48">source</a></section><h2><a class="nav-anchor" id="Working-with-several-functors-at-once-1" href="#Working-with-several-functors-at-once-1">Working with several functors at once</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.evaluate_functors!" href="#InplaceArrays.Functors.evaluate_functors!"><code>InplaceArrays.Functors.evaluate_functors!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evaluate_functors!(caches::Tuple,fs::Tuple,x...) -&gt; Tuple</code></pre><p>Evaluates the functors in the tuple <code>fs</code> at the arguments <code>x...</code> by using the corresponding cache objects in the tuple <code>caches</code>. The result is also a tuple containing the result for each functor in <code>fs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4937974e4d0f3039c78c13d0f2691e780ba7518a/src/Functors.jl#L85-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.functor_caches" href="#InplaceArrays.Functors.functor_caches"><code>InplaceArrays.Functors.functor_caches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">functor_caches(fs::Tuple,x...) -&gt; Tuple</code></pre><p>Returns a tuple with the cache corresponding to each functor in <code>fs</code> for the arguments <code>x...</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4937974e4d0f3039c78c13d0f2691e780ba7518a/src/Functors.jl#L62-L67">source</a></section><h2><a class="nav-anchor" id="Broadcasting-1" href="#Broadcasting-1">Broadcasting</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.bcast" href="#InplaceArrays.Functors.bcast"><code>InplaceArrays.Functors.bcast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bcast(f::Function)</code></pre><p>Returns a functor object that represents the &quot;boradcasted&quot; version of the given function <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; op = bcast(*)
InplaceArrays.Functors.BCasted{typeof(*)}(*)

julia&gt; x = ones(2,3)
2×3 Array{Float64,2}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; y = 2
2

julia&gt; evaluate_functor(op,x,y)
2×3 CachedArray{Float64,2,Array{Float64,2}}:
 2.0  2.0  2.0
 2.0  2.0  2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4937974e4d0f3039c78c13d0f2691e780ba7518a/src/Functors.jl#L133-L158">source</a></section><h2><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.compose_functors" href="#InplaceArrays.Functors.compose_functors"><code>InplaceArrays.Functors.compose_functors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">c = compose_functors(g,fs...)</code></pre><p>Returns an object <code>c</code> representing the &quot;composition&quot; of functor <code>g</code> with several functors <code>fs</code>. The resulting object <code>c</code> is such that</p><pre><code class="language-julia">evaluate_functor(c,x...)</code></pre><p>is equivalent to</p><pre><code class="language-julia">fxs = evaluate_functors(fs,x...)
evaluate_functor(g,fxs...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4937974e4d0f3039c78c13d0f2691e780ba7518a/src/Functors.jl#L197-L211">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../Arrays/"><span class="direction">Next</span><span class="title">Extended AbstractArray interface</span></a></footer></article></body></html>
