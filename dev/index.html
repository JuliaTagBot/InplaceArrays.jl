<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>InplaceArrays.jl · InplaceArrays</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InplaceArrays</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>InplaceArrays.jl</a><ul class="internal"><li><a class="toctext" href="#The-Functor-interface-1">The Functor interface</a></li><li><a class="toctext" href="#Default-implementations-1">Default implementations</a></li><li><a class="toctext" href="#Evaluating-a-functor-without-cache-1">Evaluating a functor without cache</a></li><li><a class="toctext" href="#Working-with-several-functors-at-once-1">Working with several functors at once</a></li><li><a class="toctext" href="#Broadcasting-1">Broadcasting</a></li><li><a class="toctext" href="#Composition-1">Composition</a></li><li><a class="toctext" href="#Extended-AbstractArray-interface-1">Extended AbstractArray interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>InplaceArrays.jl</a></li></ul><a class="edit-page" href="https://github.com/fverdugo/InplaceArrays.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>InplaceArrays.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="InplaceArrays.jl-1" href="#InplaceArrays.jl-1">InplaceArrays.jl</a></h1><p>Documentation for InplaceArrays.jl</p><h2><a class="nav-anchor" id="The-Functor-interface-1" href="#The-Functor-interface-1">The Functor interface</a></h2><p>Often, it is needed to implement functions that need some scratch data (e.g., pre-allocating the output). The question is, <em>where to store this data?</em> There are three main answers to this question: 1) store the data in the function object as part of its state, 2) allocate the scratch data each time the operation is performed, and 3) the user allocates and passes the scratch data when needed. Clearly, 1) it is not save if several calls to the operation are using the same scratch data (e.g., multi-threading). 2) is save, but it can be inefficient if the operation is performed at low granularity. 3) is both save and efficient, but requires some extra work by the user.</p><p>In Gridap, we adopt the 3rd option. In order to unify the interfaces of functions using this approach, we introduce the <em>Functor interface</em>. Any type is referred to as a <em>Functor</em> if it implements the following interface. We rely in duck typing here. There is not an abstract type representing a functor.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.evaluate_functor!" href="#InplaceArrays.Functors.evaluate_functor!"><code>InplaceArrays.Functors.evaluate_functor!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">y = evaluate_functor!(cache,f,x...)</code></pre><p>Evaluates the functor <code>f</code> at the arguments <code>x...</code> using the scratch data provided in the given <code>cache</code> object. The <code>cache</code> object is built with the <a href="#InplaceArrays.Functors.functor_cache"><code>functor_cache</code></a> function using arguments of the same type as in <code>x...</code> In general, the returned value <code>y</code> can share some part of its state with the <code>cache</code> object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various <code>cache</code> objects (e.g., one cache per thread).</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Functors.jl#L26-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.functor_cache" href="#InplaceArrays.Functors.functor_cache"><code>InplaceArrays.Functors.functor_cache</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cache = functor_cache(f,x...)</code></pre><p>Returns the <code>cache</code> needed to evaluate functor <code>f</code> with arguments of the same type as the objects in <code>x...</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Functors.jl#L18-L23">source</a></section><h2><a class="nav-anchor" id="Default-implementations-1" href="#Default-implementations-1">Default implementations</a></h2><p>We provide some default (obvious) implementations of this interface so that <code>Function</code>, <code>Number</code>, and <code>AbstractArray</code> objects behave like functors.</p><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>Calling the <code>+</code> function via the functor interface.</p><pre><code class="language-julia-repl">julia&gt; cache = functor_cache(+,0,0)

julia&gt; evaluate_functor!(cache,+,1,2)
3

julia&gt; evaluate_functor!(cache,+,-1,10)
9</code></pre><p><code>Number</code> and <code>AbstractArray</code> objects behave like &quot;constant&quot; functors.</p><pre><code class="language-julia-repl">julia&gt; a = 2.0
2.0

julia&gt; cache = functor_cache(a,0)

julia&gt; evaluate_functor!(cache,a,1)
2.0

julia&gt; evaluate_functor!(cache,a,2)
2.0

julia&gt; evaluate_functor!(cache,a,3)
2.0</code></pre><h2><a class="nav-anchor" id="Evaluating-a-functor-without-cache-1" href="#Evaluating-a-functor-without-cache-1">Evaluating a functor without cache</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.evaluate_functor" href="#InplaceArrays.Functors.evaluate_functor"><code>InplaceArrays.Functors.evaluate_functor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evaluate_functor(f,x...)</code></pre><p>Evaluate the fuctor <code>f</code> at the arguments <code>x...</code> by creating a temporary cache internally. This functions is equivalent to</p><pre><code class="language-jl">cache = functor_cache(f,x...)
evaluate_functor!(cache,f,x...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Functors.jl#L39-L48">source</a></section><h2><a class="nav-anchor" id="Working-with-several-functors-at-once-1" href="#Working-with-several-functors-at-once-1">Working with several functors at once</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.evaluate_functors!" href="#InplaceArrays.Functors.evaluate_functors!"><code>InplaceArrays.Functors.evaluate_functors!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evaluate_functors!(caches::Tuple,fs::Tuple,x...) -&gt; Tuple</code></pre><p>Evaluates the functors in the tuple <code>fs</code> at the arguments <code>x...</code> by using the corresponding cache objects in the tuple <code>caches</code>. The result is also a tuple containing the result for each functor in <code>fs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Functors.jl#L85-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.functor_caches" href="#InplaceArrays.Functors.functor_caches"><code>InplaceArrays.Functors.functor_caches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">functor_caches(fs::Tuple,x...) -&gt; Tuple</code></pre><p>Returns a tuple with the cache corresponding to each functor in <code>fs</code> for the arguments <code>x...</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Functors.jl#L62-L67">source</a></section><h2><a class="nav-anchor" id="Broadcasting-1" href="#Broadcasting-1">Broadcasting</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.bcast" href="#InplaceArrays.Functors.bcast"><code>InplaceArrays.Functors.bcast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bcast(f::Function)</code></pre><p>Returns a functor object that represents the &quot;boradcasted&quot; version of the given function <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; op = bcast(*)
InplaceArrays.Functors.BCasted{typeof(*)}(*)

julia&gt; x = ones(2,3)
2×3 Array{Float64,2}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; y = 2
2

julia&gt; evaluate_functor(op,x,y)
2×3 CachedArray{Float64,2,Array{Float64,2}}:
 2.0  2.0  2.0
 2.0  2.0  2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Functors.jl#L133-L158">source</a></section><h2><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Functors.compose_functors" href="#InplaceArrays.Functors.compose_functors"><code>InplaceArrays.Functors.compose_functors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">c = compose_functors(g,fs...)</code></pre><p>Returns an object <code>c</code> representing the &quot;composition&quot; of functor <code>g</code> with several functors <code>fs</code>. The resulting object <code>c</code> is such that</p><pre><code class="language-julia">evaluate_functor(c,x...)</code></pre><p>is equivalent to</p><pre><code class="language-julia">fxs = evaluate_functors(fs,x...)
evaluate_functor(g,fxs...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Functors.jl#L197-L211">source</a></section><h2><a class="nav-anchor" id="Extended-AbstractArray-interface-1" href="#Extended-AbstractArray-interface-1">Extended AbstractArray interface</a></h2><p>When implementing new array types, we encounter a similar problem than when implementing some functions : It can be needed some scratch data (e.g., allocating the output), when recovering an item from an array (typically if the array elements are mutable or non-isbits objects, e.g., for &quot;lazy&quot; array of arrays). Here, we adopt the same solution as for functors: the user provides the scratch data. However, the Julia array interface does not support this approach. When calling <code>a[i]</code>, in order to get the element with index <code>i</code> in array <code>a</code>, there is no extra argument for the scratch data. In order to circumvent this problem, we add new methods to the <code>AbstractArray</code> interface of Julia. We provide default implementations to the new methods, so that any <code>AbstractArray</code> can be used with the extended interface. The most important among the new methods is <a href="#InplaceArrays.Arrays.getindex!"><code>getindex!</code></a>, which allows to recover an item in the array by passing some scratch data. The new mehtods are listed below.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.getindex!" href="#InplaceArrays.Arrays.getindex!"><code>InplaceArrays.Arrays.getindex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getindex!(cache,a::AbstractArray,i...)</code></pre><p>Returns the item of the array <code>a</code> associated with index <code>i</code> by (possibly) using the scratch data passed in the <code>cache</code> object.</p><p>It defaults to</p><pre><code class="language-none">getindex!(cache,a::AbstractArray,i...) = a[i...]</code></pre><p>The <code>cache</code> object is constructed with the <a href="#InplaceArrays.Arrays.array_cache"><code>array_cache</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-jldocstests">julia&gt; a = collect(1:4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; cache = array_cache(a)

julia&gt; getindex!(cache,a,2)
2

julia&gt; getindex!(cache,a,4)
4</code></pre><p>In this example, using the extended interface provides little benefit, but for new array types that need scratch data, efficient implementations of <code>getindex!</code> can make a performance difference by avoiding  low granularity allocations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Arrays.jl#L178-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.array_cache" href="#InplaceArrays.Arrays.array_cache"><code>InplaceArrays.Arrays.array_cache</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">array_cache(a::AbstractArray)</code></pre><p>Returns a cache object to be used in the <a href="#InplaceArrays.Arrays.getindex!"><code>getindex!</code></a> function. It defaults to </p><pre><code class="language-none">array_cache(a::T) where T = nothing</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(false)</code>, and </p><pre><code class="language-none">function array_cache(a::T) where T
  hash = Dict{UInt,Any}()
  array_cache(hash,a)
end</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(true)</code>, see the <a href="#InplaceArrays.Arrays.uses_hash"><code>uses_hash</code></a> function. In the later case, the type <code>T</code> should implement the following signature:</p><pre><code class="language-none">array_cache(hash::Dict,a::AbstractArray)</code></pre><p>where we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object <code>a</code> has already build a cache and re-use it as follows</p><pre><code class="language-none">id = objectid(a)
if haskey(hash,id)
  cache = hash[id] # Reuse cache
else
  cache = ... # Build a new cache depending on your needs
  hash[id] = cache # Register the cache in the hash table
end</code></pre><p>In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Arrays.jl#L79-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.uses_hash" href="#InplaceArrays.Arrays.uses_hash"><code>InplaceArrays.Arrays.uses_hash</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">uses_hash(::Type{T}) where T &lt;:AbstractArray</code></pre><p>This function is used to specify if the type <code>T</code> uses the hash-based mechanism to reuse caches.  It should return either <code>Val(true)</code> or <code>Val(false)</code>. It defaults to</p><pre><code class="language-none">uses_hash(::Type{&lt;:AbstractArray}) = Val(false)</code></pre><p>Once this function is defined for the type <code>T</code> it can also be called on instances of <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; uses_hash(Matrix{Float64})
Val{false}()

julia&gt; a = ones(2,3)
2×3 Array{Float64,2}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; uses_hash(a)
Val{false}()
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Arrays.jl#L135-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.testitem" href="#InplaceArrays.Arrays.testitem"><code>InplaceArrays.Arrays.testitem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">testitem(a::AbstractArray)</code></pre><p>Returns an arbitrary instance of <code>eltype(a)</code>. The default returned value is the first entry in the array if <code>length(a)&gt;0</code> and <code>testvalue(eltype(a))</code> if <code>length(a)==0</code> See the <a href="#InplaceArrays.Arrays.testvalue"><code>testvalue</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Arrays.jl#L41-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Arrays.testvalue" href="#InplaceArrays.Arrays.testvalue"><code>InplaceArrays.Arrays.testvalue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">testvalue(::Type{T}) where T</code></pre><p>Returns an arbitrary instance of type <code>T</code>. It defaults to <code>zero(T)</code> for non-array types and to an empty array for array types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/eb84ef4eb08054562870f34a7c598e49628de564/src/Arrays.jl#L27-L32">source</a></section><footer><hr/></footer></article></body></html>
