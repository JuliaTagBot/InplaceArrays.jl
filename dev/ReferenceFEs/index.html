<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gridap.ReferenceFEs · InplaceArrays</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InplaceArrays</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../Gridap/">Gridap</a></li><li><a class="toctext" href="../Helpers/">Gridap.Helpers</a></li><li><a class="toctext" href="../Inference/">Gridap.Inference</a></li><li><a class="toctext" href="../TensorValues/">Gridap.TensorValues</a></li><li><a class="toctext" href="../Arrays/">Gridap.Arrays</a></li><li><a class="toctext" href="../Fields/">Gridap.Fields</a></li><li><a class="toctext" href="../Polynomials/">Gridap.Polynomials</a></li><li class="current"><a class="toctext" href>Gridap.ReferenceFEs</a><ul class="internal"><li><a class="toctext" href="#Polytopes-1">Polytopes</a></li><li><a class="toctext" href="#Degrees-of-freedom-1">Degrees of freedom</a></li><li><a class="toctext" href="#Reference-Finite-Elements-1">Reference Finite Elements</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Gridap.ReferenceFEs</a></li></ul><a class="edit-page" href="https://github.com/fverdugo/InplaceArrays.jl/blob/master/docs/src/ReferenceFEs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Gridap.ReferenceFEs</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Gridap.ReferenceFEs-1" href="#Gridap.ReferenceFEs-1">Gridap.ReferenceFEs</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs" href="#InplaceArrays.ReferenceFEs"><code>InplaceArrays.ReferenceFEs</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>The exported names are</p><ul><li><a href="#InplaceArrays.ReferenceFEs.Dof"><code>Dof</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.ExtrusionPolytope"><code>ExtrusionPolytope</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.GenericRefFE"><code>GenericRefFE</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.HEX"><code>HEX</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.HEX_AXIS"><code>HEX_AXIS</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.INVALID_PERM"><code>INVALID_PERM</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.LagrangianDofBasis"><code>LagrangianDofBasis</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.LagrangianRefFE"><code>LagrangianRefFE</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.PYRAMID"><code>PYRAMID</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.Polytope"><code>Polytope</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.QUAD"><code>QUAD</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.ReferenceFE"><code>ReferenceFE</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.SEGMENT"><code>SEGMENT</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.SerendipityRefFE"><code>SerendipityRefFE</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.TET"><code>TET</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.TET_AXIS"><code>TET_AXIS</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.TRI"><code>TRI</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.VERTEX"><code>VERTEX</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.WEDGE"><code>WEDGE</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_face_orders-Tuple{InplaceArrays.ReferenceFEs.Polytope,InplaceArrays.ReferenceFEs.Polytope,Int64,Any}"><code>compute_face_orders</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T"><code>compute_lagrangian_reffaces</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T"><code>compute_monomial_basis</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>compute_nodes</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_own_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>compute_own_nodes</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_own_nodes_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>compute_own_nodes_permutations</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_shapefuns-Tuple{Any,Any}"><code>compute_shapefuns</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.dof_cache-Tuple{Any,Any}"><code>dof_cache</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.dof_return_type-Tuple{Any,Any}"><code>dof_return_type</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.evaluate_dof-Tuple{Any,Any}"><code>evaluate_dof</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.evaluate_dof!-Tuple{Any,Any,Any}"><code>evaluate_dof!</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.evaluate_dof_array-Tuple{AbstractArray,AbstractArray}"><code>evaluate_dof_array</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_dimrange-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_dimrange</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_dof_to_comp-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>get_dof_to_comp</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_dof_to_node-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>get_dof_to_node</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_dofs</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_edge_tangents-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_edge_tangents</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_face_own_dofids-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_face_own_dofids</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_facedims-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_facedims</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_faces</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_facet_normals-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_facet_normals</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_facet_orientations-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_facet_orientations</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_node_and_comp_to_dof-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>get_node_and_comp_to_dof</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_node_coordinates-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>get_node_coordinates</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_offset-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}"><code>get_offset</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_offsets-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_offsets</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_own_dofs_permutations-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_own_dofs_permutations</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_polytope-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_polytope</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_prebasis-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_prebasis</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_shapefuns-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_shapefuns</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vertex_coordinates-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vertex_coordinates</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vertex_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vertex_permutations</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vtkid-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vtkid</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vtknodes-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vtknodes</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.num_dims-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>num_dims</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.num_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>num_dofs</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.num_edges-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>num_edges</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.num_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>num_faces</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.num_facets-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>num_facets</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.num_vertices-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>num_vertices</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.test_dof-Tuple{Any,Any,Any,Function}"><code>test_dof</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.test_polytope-Union{Tuple{InplaceArrays.ReferenceFEs.Polytope{D}}, Tuple{D}} where D"><code>test_polytope</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.test_reference_fe-Union{Tuple{InplaceArrays.ReferenceFEs.ReferenceFE{D}}, Tuple{D}} where D"><code>test_reference_fe</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEs.jl#L1-L5">source</a></section><h2><a class="nav-anchor" id="Polytopes-1" href="#Polytopes-1">Polytopes</a></h2><h3><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.Polytope" href="#InplaceArrays.ReferenceFEs.Polytope"><code>InplaceArrays.ReferenceFEs.Polytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type Polytope{D}</code></pre><p>Abstract type representing a polytope (i.e., a polyhedron in arbitrary dimensions). <code>D</code> is the environment dimension (typically, 0, 1, 2, or 3). This type parameter is needed since there are functions in the  <code>Polytope</code> interface that return containers with <code>Point{D}</code> objects. We adopt the <a href="https://en.wikipedia.org/wiki/Polytope">usual nomenclature</a> for polytope-related objects. All objects in a polytope (from vertices to the polytope itself) are called <em>n-faces</em> or simply <em>faces</em>. The notation <em>n-faces</em> is used only when it is needed to refer to the object dimension n. Otherwise we simply use <em>face</em>. In addition, we say</p><ul><li>vertex (pl. vertices): for 0-faces</li><li>edge: for 1-faces</li><li>facet: for (<code>D-1</code>)-faces</li></ul><p>The <code>Polytope</code> interface is defined by overloading the following functions</p><ul><li><a href="#InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_faces(p::Polytope)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_dimrange-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_dimrange(p::Polytope)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.Polytope"><code>Polytope{N}(p::Polytope,faceid::Integer) where N</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vertex_coordinates-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vertex_coordinates(p::Polytope)</code></a></li><li><a href="#Base.:==-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.ReferenceFEs.Polytope{D}}} where D"><code>(==)(a::Polytope{D},b::Polytope{D}) where D</code></a></li></ul><p>And optionally these ones:</p><ul><li><a href="#InplaceArrays.ReferenceFEs.get_edge_tangents-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_edge_tangents(p::Polytope)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_facet_normals-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_facet_normals(p::Polytope)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_facet_orientations-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_facet_orientations(p::Polytope)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vertex_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vertex_permutations(p::Polytope)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vtkid-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vtkid(p::Polytope)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_vtknodes-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>get_vtknodes(p::Polytope)</code></a></li></ul><p>The interface can be tested with the function</p><ul><li><a href="#InplaceArrays.ReferenceFEs.test_polytope-Union{Tuple{InplaceArrays.ReferenceFEs.Polytope{D}}, Tuple{D}} where D"><code>test_polytope</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L2-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_faces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_faces(p::Polytope) -&gt; Vector{Vector{Int}}</code></pre><p>Given a polytope <code>p</code> the function returns a vector of vectors defining the <em>incidence</em> relation of the faces in the polytope.</p><p>Each face in the polytope receives a unique integer id. The id 1 is assigned to the first 0-face. Consecutive increasing ids are assigned to the other 0-faces, then to 1-faces, and so on. The polytope itself receives the largest id which coincides with <code>num_faces(p)</code>. For a face id <code>iface</code>, <code>get_faces(p)[iface]</code> is a vector of face ids, corresponding to the faces that are <em>incident</em> with the face labeled with <code>iface</code>. That is, faces that are either on its boundary or the face itself.  In this vector of incident face ids, faces are ordered by dimension, starting with 0-faces. Within each dimension, the labels are ordered in a consistent way with the polyope object for the face <code>iface</code> itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

faces = get_faces(SEGMENT)
println(faces)

# output
Array{Int64,1}[[1], [2], [1, 2, 3]]</code></pre><p>The constant <a href="#InplaceArrays.ReferenceFEs.SEGMENT"><code>SEGMENT</code></a> is bound to a predefined instance of polytope that represents a segment. The face labels associated with a segment are <code>[1,2,3]</code>, being <code>1</code> and <code>2</code> for the vertices and  <code>3</code> for the segment itself. In this case, this function returns the vector of vectors <code>[[1],[2],[1,2,3]]</code> meaning that vertex <code>1</code> is incident with vertex <code>1</code> (idem for vertex 2), and that  the segment (id <code>3</code>) is incident with the vertices <code>1</code> and <code>2</code> and the segment itself.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L44-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_dimrange-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_dimrange-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_dimrange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_dimrange(p::Polytope) -&gt; Vector{UnitRange{Int}}</code></pre><p>Given a polytope <code>p</code> it returns a vector of ranges. The entry <code>d+1</code> in this vector contains the range of face ids for the faces of dimension <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

ranges = get_dimrange(SEGMENT)
println(ranges)

# output
UnitRange{Int64}[1:2, 3:3]</code></pre><p>Face ids for the vertices in the segment range from 1 to 2 (2 vertices), the face ids for edges in the segment range from 3 to 3 (only one edge with id 3).</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L84-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.Polytope-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}} where D" href="#InplaceArrays.ReferenceFEs.Polytope-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}} where D"><code>InplaceArrays.ReferenceFEs.Polytope</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Polytope{N}(p::Polytope,faceid::Integer) where N</code></pre><p>Returns a <code>Polytope{N}</code> object representing the &quot;reference&quot; polytope of the <code>N</code>-face with id <code>faceid</code>. The value <code>faceid</code> refers to the numeration restricted to the dimension <code>N</code> (it starts with 1 for the first <code>N</code>-face).</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L109-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_vertex_coordinates-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_vertex_coordinates-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_vertex_coordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_vertex_coordinates(p::Polytope) -&gt; Vector{Point{D,Float64}}</code></pre><p>Given a polytope <code>p</code> return a vector of points representing containing the coordinates of the vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L120-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.ReferenceFEs.Polytope{D}}} where D" href="#Base.:==-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.ReferenceFEs.Polytope{D}}} where D"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(==)(a::Polytope{D},b::Polytope{D}) where D</code></pre><p>Returns <code>true</code> if the polytopes <code>a</code> and <code>b</code> are equivalent. Otherwise, it  returns <code>false</code>. Note that the operator <code>==</code> returns <code>false</code> by default for polytopes of different dimensions. Thus, this function has to be overloaded only for the case of polytopes <code>a</code> and <code>b</code> of same dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L130-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_edge_tangents-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_edge_tangents-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_edge_tangents</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_edge_tangents(p::Polytope) -&gt; Vector{VectorValue{D,Float64}}</code></pre><p>Given a polytope <code>p</code>, returns a vector of <code>VectorValue</code> objects representing the unit tangent vectors to the polytope edges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L149-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_facet_normals-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_facet_normals-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_facet_normals</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_facet_normals(p::Polytope) -&gt; Vector{VectorValue{D,Float64}}</code></pre><p>Given a polytope <code>p</code>, returns a vector of <code>VectorValue</code> objects representing the unit outward normal vectors to the polytope facets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L159-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_facet_orientations-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_facet_orientations-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_facet_orientations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_facet_orientations(p::Polytope) -&gt; Vector{Int}</code></pre><p>Given a polytope <code>p</code> returns a vector of integers of length <code>num_facets(p)</code>. Facets, whose vertices are ordered consistently with the outwards normal vector, receive value <code>1</code> in this vector. Otherwise, facets receive value <code>-1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L169-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_vertex_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_vertex_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_vertex_permutations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_vertex_permutations(p::Polytope) -&gt; Vector{Vector{Int}}</code></pre><p>Given a polytope <code>p</code>, returns a vector of vectors containing all admissible permutations of the polytope vertices. An admissible permutation is one such that, if the vertices of the polytope are re-labeled according to this permutation, the resulting polytope preserves the shape of the original one.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

perms = get_vertex_permutations(SEGMENT)
println(perms)

# output
Array{Int64,1}[[1, 2], [2, 1]]
</code></pre><p>The first admissible permutation for a segment is <code>[1,2]</code>,i.e., the identity. The second one is <code>[2,1]</code>, i.e., the first vertex is relabeled as <code>2</code> and the second vertex is relabeled as <code>1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L181-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_vtkid-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_vtkid-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_vtkid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_vtkid(p::Polytope) -&gt; Int</code></pre><p>Given a polytope <code>p</code>, returns an integer with its vtk identifier. Overloading of this function is needed only in order to visualize the underlying polytope with Paraview.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L210-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_vtknodes-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_vtknodes-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_vtknodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_vtknodes(p::Polytope) -&gt; Vector{Int}</code></pre><p>Given a polytope <code>p</code>, returns a vector of integers representing a permutation of the polytope vertices required to relabel the vertices according the criterion adopted in Paraview. Overloading of this function is needed only in order to visualize the underlying polytope with Paraview.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L221-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.test_polytope-Union{Tuple{InplaceArrays.ReferenceFEs.Polytope{D}}, Tuple{D}} where D" href="#InplaceArrays.ReferenceFEs.test_polytope-Union{Tuple{InplaceArrays.ReferenceFEs.Polytope{D}}, Tuple{D}} where D"><code>InplaceArrays.ReferenceFEs.test_polytope</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">test_polytope(p::Polytope{D}; optional::Bool=false) where D</code></pre><p>Function that stresses out the functions in the <code>Polytope</code> interface. It tests whether the function in the polytope interface are defined for the given object, and whether they return objects of the expected type. With <code>optional=false</code> (the default), only the mandatory functions are checked. With <code>optional=true</code>, the optional functions are also tested except <code>get_vtkid</code>  and <code>get_vtknodes</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L443-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_dims-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.num_dims-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.num_dims</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_dims(::Type{&lt;:Polytope{D}}) where D
num_dims(p::Polytope{D}) where D</code></pre><p>Returns <code>D</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L238-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.num_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.num_faces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_faces(p::Polytope)</code></pre><p>Returns the total number of faces in polytope <code>p</code> (from vertices to the polytope itself).</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L246-L250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}" href="#InplaceArrays.ReferenceFEs.num_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}"><code>InplaceArrays.ReferenceFEs.num_faces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_faces(p::Polytope,dim::Integer)</code></pre><p>Returns the number of faces of dimension <code>dim</code> in polytope <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L255-L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_facets-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.num_facets-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.num_facets</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_facets(p::Polytope)</code></pre><p>Returns the number of facets in the polytope <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L264-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_edges-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.num_edges-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.num_edges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_edges(p::Polytope)</code></pre><p>Returns the number of edges in the polytope <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L278-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_vertices-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.num_vertices-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.num_vertices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_vertices(p::Polytope)</code></pre><p>Returns the number of vertices in the polytope <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L292-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_facedims-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_facedims-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_facedims</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_facedims(p::Polytope) -&gt; Vector{Int}</code></pre><p>Given a polytope <code>p</code>, returns a vector indicating the dimension of each face in the polytope</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

dims = get_facedims(SEGMENT)
println(dims)

# output
[0, 0, 1]
</code></pre><p>The first two faces in the segment (the two vertices) have dimension 0 and the  third face (the segment itself) has dimension 1</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L301-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_offsets-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.get_offsets-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.get_offsets</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_offsets(p::Polytope) -&gt; Vector{Int}</code></pre><p>Given a polytope <code>p</code>, it returns a vector of integers. The position in the <code>d+1</code> entry in this vector is the offset that transforms a face id in the global numeration in the polytope to the numeration restricted to faces to dimension <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

offsets = get_offsets(SEGMENT)
println(offsets)

# output
[0, 2]
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L335-L355">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_offset-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}" href="#InplaceArrays.ReferenceFEs.get_offset-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}"><code>InplaceArrays.ReferenceFEs.get_offset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_offset(p::Polytope,d::Integer)</code></pre><p>Equivalent to <code>get_offsets(p)[d+1]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L370-L374">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer,Integer}" href="#InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer,Integer}"><code>InplaceArrays.ReferenceFEs.get_faces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_faces(p::Polytope,dimfrom::Integer,dimto::Integer) -&gt; Vector{Vector{Int}}</code></pre><p>For <code>dimfrom &gt;= dimto</code> returns a vector that for each face of dimension <code>dimfrom</code> stores a vector of the ids of faces of dimension <code>dimto</code> on its boundary.</p><p>For <code>dimfrom &lt; dimto</code> returns a vector that for each face of <code>dimfrom</code> stores a vector of the face ids of faces of dimension <code>dimto</code> that touch it.</p><p>The numerations used in this funcitons are the ones restricted to each dimension.</p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

edge_to_vertices = get_faces(QUAD,1,0)
println(edge_to_vertices)

vertex_to_edges_around = get_faces(QUAD,0,1)
println(vertex_to_edges_around)

# output
Array{Int64,1}[[1, 2], [3, 4], [1, 3], [2, 4]]
Array{Int64,1}[[1, 3], [1, 4], [2, 3], [2, 4]]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Polytopes.jl#L379-L404">source</a></section><h3><a class="nav-anchor" id="Extrusion-polytopes-1" href="#Extrusion-polytopes-1">Extrusion polytopes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.ExtrusionPolytope" href="#InplaceArrays.ReferenceFEs.ExtrusionPolytope"><code>InplaceArrays.ReferenceFEs.ExtrusionPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ExtrusionPolytope{D} &lt;: Polytope{D}
  extrusion::Point{D,Int}
  # + private fields
end</code></pre><p>Concrete type for polytopes that can be represented with an &quot;extrusion&quot; tuple. The underlying extrusion is available in the field <code>extrusion</code>. Instances of this type can be obtained with the constructors</p><ul><li><a href="#InplaceArrays.ReferenceFEs.Polytope-Tuple{Vararg{Int64,N} where N}"><code>Polytope(extrusion::Int...)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.ExtrusionPolytope-Tuple{Vararg{Int64,N} where N}"><code>ExtrusionPolytope(extrusion::Int...)</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L10-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.ExtrusionPolytope-Tuple{Vararg{Int64,N} where N}" href="#InplaceArrays.ReferenceFEs.ExtrusionPolytope-Tuple{Vararg{Int64,N} where N}"><code>InplaceArrays.ReferenceFEs.ExtrusionPolytope</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ExtrusionPolytope(extrusion::Int...)</code></pre><p>Generates an <code>ExtrusionPolytope</code> from the tuple <code>extrusion</code>. The values in <code>extrusion</code> are either equal to the constant <a href="#InplaceArrays.ReferenceFEs.HEX_AXIS"><code>HEX_AXIS</code></a> or the constant <a href="#InplaceArrays.ReferenceFEs.TET_AXIS"><code>TET_AXIS</code></a>.</p><p><strong>Examples</strong></p><p>Creating a quadrilateral, a triangle, and a wedge</p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

quad = ExtrusionPolytope(HEX_AXIS,HEX_AXIS)

tri = ExtrusionPolytope(TET_AXIS,TET_AXIS)

wedge = ExtrusionPolytope(TET_AXIS,TET_AXIS,HEX_AXIS)

println(quad == QUAD)
println(tri == TRI)
println(wedge == WEDGE)

# output
true
true
true
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L49-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.Polytope-Tuple{Vararg{Int64,N} where N}" href="#InplaceArrays.ReferenceFEs.Polytope-Tuple{Vararg{Int64,N} where N}"><code>InplaceArrays.ReferenceFEs.Polytope</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Polytope(extrusion::Int...)</code></pre><p>Equivalent to <code>ExtrusionPolytope(extrusion...)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L34-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.HEX_AXIS" href="#InplaceArrays.ReferenceFEs.HEX_AXIS"><code>InplaceArrays.ReferenceFEs.HEX_AXIS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Constant to be used in order to indicate a hex-like extrusion axis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L85-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.TET_AXIS" href="#InplaceArrays.ReferenceFEs.TET_AXIS"><code>InplaceArrays.ReferenceFEs.TET_AXIS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Constant to be used in order to indicate a tet-like extrusion axis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L90-L92">source</a></section><h3><a class="nav-anchor" id="Pre-defined-polytope-instances-1" href="#Pre-defined-polytope-instances-1">Pre-defined polytope instances</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.VERTEX" href="#InplaceArrays.ReferenceFEs.VERTEX"><code>InplaceArrays.ReferenceFEs.VERTEX</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const VERTEX = Polytope()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L476-L478">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.SEGMENT" href="#InplaceArrays.ReferenceFEs.SEGMENT"><code>InplaceArrays.ReferenceFEs.SEGMENT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const SEGMENT = Polytope(HEX_AXIS)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L481-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.TRI" href="#InplaceArrays.ReferenceFEs.TRI"><code>InplaceArrays.ReferenceFEs.TRI</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const TRI = Polytope(TET_AXIS,TET_AXIS)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L487-L489">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.QUAD" href="#InplaceArrays.ReferenceFEs.QUAD"><code>InplaceArrays.ReferenceFEs.QUAD</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const QUAD = Polytope(HEX_AXIS,HEX_AXIS)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L492-L494">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.TET" href="#InplaceArrays.ReferenceFEs.TET"><code>InplaceArrays.ReferenceFEs.TET</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const TET = Polytope(TET_AXIS,TET_AXIS,TET_AXIS)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L497-L499">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.HEX" href="#InplaceArrays.ReferenceFEs.HEX"><code>InplaceArrays.ReferenceFEs.HEX</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const HEX = Polytope(HEX_AXIS,HEX_AXIS,HEX_AXIS)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L502-L504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.WEDGE" href="#InplaceArrays.ReferenceFEs.WEDGE"><code>InplaceArrays.ReferenceFEs.WEDGE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const WEDGE = Polytope(TET_AXIS,TET_AXIS,HEX_AXIS)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L507-L509">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.PYRAMID" href="#InplaceArrays.ReferenceFEs.PYRAMID"><code>InplaceArrays.ReferenceFEs.PYRAMID</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const PYRAMID = Polytope(HEX_AXIS,HEX_AXIS,TET_AXIS)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ExtrusionPolytopes.jl#L512-L514">source</a></section><h2><a class="nav-anchor" id="Degrees-of-freedom-1" href="#Degrees-of-freedom-1">Degrees of freedom</a></h2><h3><a class="nav-anchor" id="Interface-2" href="#Interface-2">Interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.Dof" href="#InplaceArrays.ReferenceFEs.Dof"><code>InplaceArrays.ReferenceFEs.Dof</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type Dof &lt;: Kernel</code></pre><p>Abstract type representing a degree of freedom (DOF), a basis of DOFs, and related objects. These different cases are distinguished by the return type obtained when evaluating the <code>Dof</code> object on a <code>Field</code> object. See function <a href="#InplaceArrays.ReferenceFEs.evaluate_dof!-Tuple{Any,Any,Any}"><code>evaluate_dof!</code></a> for more details.</p><p>The following functions needs to be overloaded</p><ul><li><a href="#InplaceArrays.ReferenceFEs.dof_cache-Tuple{Any,Any}"><code>dof_cache</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.evaluate_dof!-Tuple{Any,Any,Any}"><code>evaluate_dof!</code></a></li></ul><p>The following functions can be overloaded optionally</p><ul><li><a href="#InplaceArrays.ReferenceFEs.dof_return_type-Tuple{Any,Any}"><code>dof_return_type</code></a></li></ul><p>The interface is tested with</p><ul><li><a href="#InplaceArrays.ReferenceFEs.test_dof-Tuple{Any,Any,Any,Function}"><code>test_dof</code></a></li></ul><p>In most of the cases it is not strictly needed that types that implement this interface inherit from <code>Dof</code>. However, we recommend to inherit from <code>Dof</code>, when possible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L2-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.evaluate_dof!-Tuple{Any,Any,Any}" href="#InplaceArrays.ReferenceFEs.evaluate_dof!-Tuple{Any,Any,Any}"><code>InplaceArrays.ReferenceFEs.evaluate_dof!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate_dof!(cache,dof,field)</code></pre><p>Evaluates the dof <code>dof</code> with the field <code>field</code>. It can return either an scalar value or an array of scalar values depending the case. The <code>cache</code> object is computed with function <a href="#InplaceArrays.ReferenceFEs.dof_cache-Tuple{Any,Any}"><code>dof_cache</code></a>.</p><p>When a mathematical dof is evaluated on a physical field, a scalar number is returned. If either the <code>Dof</code> object is a basis of DOFs, or the <code>Field</code> object is a basis of fields, or both objects are bases, then the returned object is an array of scalar numbers. The first dimensions in the resulting array are for the <code>Dof</code> object and the last ones for the <code>Field</code> object. E.g, a basis of <code>nd</code> DOFs evaluated at physical field returns a vector of <code>nd</code> entries. A basis of <code>nd</code> DOFs evaluated at a basis of <code>nf</code> fields returns a matrix of size <code>(nd,nf)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L38-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.dof_cache-Tuple{Any,Any}" href="#InplaceArrays.ReferenceFEs.dof_cache-Tuple{Any,Any}"><code>InplaceArrays.ReferenceFEs.dof_cache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dof_cache(dof,field)</code></pre><p>Returns the cache needed to call <code>evaluate_dof!(cache,dof,field)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L29-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.dof_return_type-Tuple{Any,Any}" href="#InplaceArrays.ReferenceFEs.dof_return_type-Tuple{Any,Any}"><code>InplaceArrays.ReferenceFEs.dof_return_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dof_return_type(dof,field)</code></pre><p>Returns the type for the value obtained with evaluating <code>dof</code> with <code>field</code>.</p><p>It defaults to</p><pre><code class="language-none">typeof(evaluate_dof(dof,field))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L56-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.test_dof-Tuple{Any,Any,Any,Function}" href="#InplaceArrays.ReferenceFEs.test_dof-Tuple{Any,Any,Any,Function}"><code>InplaceArrays.ReferenceFEs.test_dof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">test_dof(dof,field,v,comp::Function=(==))</code></pre><p>Test that the <code>Dof</code> interface is properly implemented for object <code>dof</code>. It also checks if the object <code>dof</code> when evaluated at the field <code>field</code> returns the same value as <code>v</code>. Comparison is made with the <code>comp</code> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L71-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.evaluate_dof-Tuple{Any,Any}" href="#InplaceArrays.ReferenceFEs.evaluate_dof-Tuple{Any,Any}"><code>InplaceArrays.ReferenceFEs.evaluate_dof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate_dof(dof,field)</code></pre><p>Equivalent to</p><pre><code class="language-none">cache = dof_cache(dof,field)
evaluate_dof!(cache,dof,field)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L98-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Fields.evaluate-Tuple{InplaceArrays.ReferenceFEs.Dof,Any}" href="#InplaceArrays.Fields.evaluate-Tuple{InplaceArrays.ReferenceFEs.Dof,Any}"><code>InplaceArrays.Fields.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate(dof::Dof,field)</code></pre><p>Equivalent to <code>evaluate_dof(dof,field)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L111-L115">source</a></section><h3><a class="nav-anchor" id="Working-with-arrays-of-DOFs-1" href="#Working-with-arrays-of-DOFs-1">Working with arrays of DOFs</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.evaluate_dof_array-Tuple{AbstractArray,AbstractArray}" href="#InplaceArrays.ReferenceFEs.evaluate_dof_array-Tuple{AbstractArray,AbstractArray}"><code>InplaceArrays.ReferenceFEs.evaluate_dof_array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate_dof_array(dof::AbstractArray,field::AbstractArray)</code></pre><p>Evaluates the <code>Dof</code> objects in the array <code>dof</code> at the <code>Field</code> objects at the array <code>field</code> element by element.</p><p>The result is numerically equivalent to</p><pre><code class="language-none">map(evaluate_dof, dof, field)</code></pre><p>but it is described with a more memory-friendly lazy type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L120-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.Fields.evaluate-Tuple{AbstractArray{#s5,N} where N where #s5&lt;:InplaceArrays.ReferenceFEs.Dof,AbstractArray}" href="#InplaceArrays.Fields.evaluate-Tuple{AbstractArray{#s5,N} where N where #s5&lt;:InplaceArrays.ReferenceFEs.Dof,AbstractArray}"><code>InplaceArrays.Fields.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate(dof::AbstractArray{&lt;:Dof},field::AbstractArray)</code></pre><p>Equivalent to <code>evaluate_dof_array(dof,field)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/Dofs.jl#L141-L145">source</a></section><h3><a class="nav-anchor" id="Lagrangian-dof-bases-1" href="#Lagrangian-dof-bases-1">Lagrangian dof bases</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.LagrangianDofBasis" href="#InplaceArrays.ReferenceFEs.LagrangianDofBasis"><code>InplaceArrays.ReferenceFEs.LagrangianDofBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct LagrangianDofBasis{P,V} &lt;: Dof
  nodes::Vector{P}
  dof_to_node::Vector{Int}
  dof_to_comp::Vector{Int}
  node_and_comp_to_dof::Vector{V}
end</code></pre><p>Type that implements a Lagrangian dof basis.</p><p>Fields:</p><ul><li><code>nodes::Vector{P}</code> vector of points (<code>P&lt;:Point</code>) storing the nodal coordinates</li><li><code>node_and_comp_to_dof::Vector{V}</code> vector such that <code>node_and_comp_to_dof[node][comp]</code> returns the dof associated with node <code>node</code> and the component <code>comp</code> in the type <code>V</code>.</li><li><code>dof_to_node::Vector{Int}</code> vector of integers such that <code>dof_to_node[dof]</code> returns the node id associated with dof id <code>dof</code>.</li><li><code>dof_to_comp::Vector{Int}</code> vector of integers such that <code>dof_to_comp[dof]</code> returns the component id associated with dof id <code>dof</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianDofBases.jl#L3-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.LagrangianDofBasis-Union{Tuple{T}, Tuple{Type{T},Array{#s5,1} where #s5&lt;:(InplaceArrays.TensorValues.MultiValue{Tuple{D},T,1,D} where T where D)}} where T" href="#InplaceArrays.ReferenceFEs.LagrangianDofBasis-Union{Tuple{T}, Tuple{Type{T},Array{#s5,1} where #s5&lt;:(InplaceArrays.TensorValues.MultiValue{Tuple{D},T,1,D} where T where D)}} where T"><code>InplaceArrays.ReferenceFEs.LagrangianDofBasis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">LagrangianDofBasis(::Type{T},nodes::Vector{&lt;:Point}) where T</code></pre><p>Creates a <code>LagrangianDofBasis</code> for fields of value type <code>T</code> associated with the vector of nodal coordinates <code>nodes</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianDofBases.jl#L28-L33">source</a></section><h2><a class="nav-anchor" id="Reference-Finite-Elements-1" href="#Reference-Finite-Elements-1">Reference Finite Elements</a></h2><h3><a class="nav-anchor" id="Interface-3" href="#Interface-3">Interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.ReferenceFE" href="#InplaceArrays.ReferenceFEs.ReferenceFE"><code>InplaceArrays.ReferenceFEs.ReferenceFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type ReferenceFE{D}</code></pre><p>Abstract type representing a Reference finite element. <code>D</code> is the underlying coordinate space dimension. We follow the Ciarlet definition. A reference finite element is defined by a polytope (cell topology), a basis of an interpolation space of top of this polytope (denoted here as the prebasis), and a basis of the dual of this space (i.e. the degrees of freedom). From this information one can compute the shape functions (i.e, the canonical basis of w.r.t. the degrees of freedom) with a simple change of basis. In addition, we also encode in this type information about how the interpolation space in a reference finite element is &quot;glued&quot; with neighbors in order to build conforming cell-wise spaces.</p><p>The <code>ReferenceFE</code> interface is defined by overloading these methods:</p><ul><li><a href="#InplaceArrays.ReferenceFEs.num_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>num_dofs(reffe::ReferenceFE)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_polytope-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_polytope(reffe::ReferenceFE)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_prebasis-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_prebasis(reffe::ReferenceFE)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_dofs(reffe::ReferenceFE)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_face_own_dofids-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_face_own_dofids(reffe::ReferenceFE)</code></a></li></ul><p>and optionally these ones:</p><ul><li><a href="#InplaceArrays.ReferenceFEs.ReferenceFE-Union{Tuple{N}, Tuple{InplaceArrays.ReferenceFEs.ReferenceFE,Integer}} where N"><code>ReferenceFE{N}(reffe::ReferenceFE,nfaceid::Integer) where N</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.get_own_dofs_permutations-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>get_own_dofs_permutations(reffe::ReferenceFE)</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L1-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.num_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.num_dofs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_dofs(reffe::ReferenceFE) -&gt; Int</code></pre><p>Returns the number of DOFs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L30-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_polytope-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.get_polytope-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.get_polytope</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_polytope(reffe::ReferenceFE) -&gt; Polytope</code></pre><p>Returns the underlying polytope object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_prebasis-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.get_prebasis-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.get_prebasis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_prebasis(reffe::ReferenceFE) -&gt; Field</code></pre><p>Returns the underlying prebasis encoded as a <code>Field</code> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L48-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.get_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.get_dofs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_dofs(reffe::ReferenceFE) -&gt; Dof</code></pre><p>Returns the underlying dof basis encoded in a <code>Dof</code> object. </p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L57-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_face_own_dofids-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.get_face_own_dofids-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.get_face_own_dofids</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_face_own_dofids(reffe::ReferenceFE) -&gt; Vector{Vector{Int}}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L66-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.ReferenceFE-Union{Tuple{N}, Tuple{InplaceArrays.ReferenceFEs.ReferenceFE,Integer}} where N" href="#InplaceArrays.ReferenceFEs.ReferenceFE-Union{Tuple{N}, Tuple{InplaceArrays.ReferenceFEs.ReferenceFE,Integer}} where N"><code>InplaceArrays.ReferenceFEs.ReferenceFE</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ReferenceFE{N}(reffe::ReferenceFE,nfaceid::Integer) where N</code></pre><p>Returns a reference FE obtained by the restriction of the given one to the face with <code>nfaceid</code> within dimension <code>N</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L75-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_own_dofs_permutations-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.get_own_dofs_permutations-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.get_own_dofs_permutations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_own_dofs_permutations(reffe::ReferenceFE) -&gt; Vector{Vector{Int}}</code></pre><p>Returns a vector of vectors indicating how the dofs owned by the reference fe have to be relabeled when the vertices of the underlying polytope are relabeled according the permutations in</p><pre><code class="language-none">polytope = get_polytope(reffe)
vertex_perms = get_vertex_permutations(polytope)</code></pre><p>That is, if the vertices are relabeled with the permutation number <code>iperm</code></p><pre><code class="language-none">oldvertex_to_newvertex = vertex_perms[iperm]</code></pre><p>The dofs are relabeled as</p><pre><code class="language-none">olddof_to_newdof = get_own_dofs_permutations(reffe)[iperm]</code></pre><p>Note that in some cases, a valid relabeling of the dofs for a corresponding relabeling of the vertices does not exist (i.e., lagrangian FEs with anisotropic order). For these permutations the corresponding vector in  <code>get_own_dofs_permutations(reffe)</code> has to be filled with the constant value <a href="#InplaceArrays.ReferenceFEs.INVALID_PERM"><code>INVALID_PERM</code></a>.</p><p><strong>Examples</strong></p><p>Relabeling of the dofs owned by the 4-th order segment</p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

order = 4
seg5 = LagrangianRefFE(Float64,SEGMENT,order)

vertexperms = get_vertex_permutations(SEGMENT)
dofperms = get_own_dofs_permutations(seg5)

println(vertexperms)
println(dofperms)

# output
Array{Int64,1}[[1, 2], [2, 1]]
Array{Int64,1}[[1, 2, 3], [3, 2, 1]]
</code></pre><p>Note that when the segment is flipped (the second permutation) the first owned dof becomes the third  owned dof, the second owned dof becomes the second one and the third becomes the first one as one would expect.</p><p>Relabeling of the dofs owned by an anisotropic quadrilateral</p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

orders = (2,3)
quad12 = LagrangianRefFE(Float64,QUAD,orders)

vertexperms = get_vertex_permutations(QUAD)
dofperms = get_own_dofs_permutations(quad12)

println(vertexperms)
println(dofperms)
println(INVALID_PERM)

# output
Array{Int64,1}[[1, 2, 3, 4], [1, 3, 2, 4], [2, 1, 4, 3], [2, 4, 1, 3], [3, 1, 4, 2], [3, 4, 1, 2], [4, 2, 3, 1], [4, 3, 2, 1]]
Array{Int64,1}[[1, 2], [0, 0], [1, 2], [0, 0], [0, 0], [2, 1], [0, 0], [2, 1]]
0</code></pre><p>Note that not all permutations are valid in this case.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L85-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.INVALID_PERM" href="#InplaceArrays.ReferenceFEs.INVALID_PERM"><code>InplaceArrays.ReferenceFEs.INVALID_PERM</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Constant of type <code>Int</code>  used to signal that a permutation is not valid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L162-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_shapefuns-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.get_shapefuns-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.get_shapefuns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_shapefuns(reffe::ReferenceFE) -&gt; Field</code></pre><p>Returns the basis of shape functions (i.e. the canonical basis) associated with the reference FE. The result is encoded as a <code>Field</code> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L170-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.compute_shapefuns-Tuple{Any,Any}" href="#InplaceArrays.ReferenceFEs.compute_shapefuns-Tuple{Any,Any}"><code>InplaceArrays.ReferenceFEs.compute_shapefuns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute_shapefuns(dofs,prebasis)</code></pre><p>Helper function used to compute the shape function basis associated with the dof basis <code>dofs</code> and the basis <code>prebasis</code>.</p><p>It is equivalent to</p><pre><code class="language-none">change = inv(evaluate(dofs,prebasis))
change_basis(prebasis,change)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L182-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.num_dims-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}" href="#InplaceArrays.ReferenceFEs.num_dims-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}"><code>InplaceArrays.ReferenceFEs.num_dims</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_dims(::Type{&lt;:ReferenceFE{D}}) where D
num_dims(reffe::ReferenceFE{D}) where D</code></pre><p>Returns <code>D</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L200-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.test_reference_fe-Union{Tuple{InplaceArrays.ReferenceFEs.ReferenceFE{D}}, Tuple{D}} where D" href="#InplaceArrays.ReferenceFEs.test_reference_fe-Union{Tuple{InplaceArrays.ReferenceFEs.ReferenceFE{D}}, Tuple{D}} where D"><code>InplaceArrays.ReferenceFEs.test_reference_fe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">test_reference_fe(reffe::ReferenceFE{D};optional::Bool=false) where D</code></pre><p>Test if the methods in the <code>ReferenceFE</code> interface are defined for the object <code>reffe</code>. If <code>optional=false</code> (the default) only the mandatory methods are checked. Otherwise, the optional methods are also tested.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L210-L216">source</a></section><h3><a class="nav-anchor" id="Generic-reference-elements-1" href="#Generic-reference-elements-1">Generic reference elements</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.GenericRefFE" href="#InplaceArrays.ReferenceFEs.GenericRefFE"><code>InplaceArrays.ReferenceFEs.GenericRefFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GenericRefFE{D} &lt;: ReferenceFE{D}
  polytope::Polytope{D}
  prebasis::Field
  dofs::Dof
  face_own_dofids::Vector{Vector{Int}}
  shapefuns::Field
  ndofs::Int
  own_dofs_permutations::Vector{Vector{Int}}
  reffaces
end</code></pre><p>This type is a <em>materialization</em> of the <code>ReferenceFE</code> interface. That is, it is a  <code>struct</code> that stores the values of all abstract methods in the <code>ReferenceFE</code> interface. This type is useful to build reference FEs from the underlying ingredients without the need to create a new type.</p><p>Note that some fields in this <code>struct</code> are type unstable deliberately in order to simplify the type signature. Don&#39;t access them in computationally expensive functions, instead extract the required fields before and pass them to the computationally expensive function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L252-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.GenericRefFE-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.Fields.Field,InplaceArrays.ReferenceFEs.Dof,Array{Array{Int64,1},1}}} where D" href="#InplaceArrays.ReferenceFEs.GenericRefFE-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.Fields.Field,InplaceArrays.ReferenceFEs.Dof,Array{Array{Int64,1},1}}} where D"><code>InplaceArrays.ReferenceFEs.GenericRefFE</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">GenericRefFE(
  polytope::Polytope{D},
  prebasis::Field,
  dofs::Dof,
  face_own_dofids::Vector{Vector{Int}};
  shapefuns::Field,
  ndofs::Int,
  own_dofs_permutations::Vector{Vector{Int}},
  reffaces) where D</code></pre><p>Constructs a <code>GenericRefFE</code> object with the provided data. Positional arguments are mandatory. All Key-word ones are optional.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/ReferenceFEInterfaces.jl#L282-L295">source</a></section><h3><a class="nav-anchor" id="Lagrangian-reference-elements-1" href="#Lagrangian-reference-elements-1">Lagrangian reference elements</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.LagrangianRefFE" href="#InplaceArrays.ReferenceFEs.LagrangianRefFE"><code>InplaceArrays.ReferenceFEs.LagrangianRefFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct LagrangianRefFE{D} &lt;: ReferenceFE{D}
  data::GenericRefFE{D}
  face_own_nodeids::Vector{Vector{Int}}
  own_nodes_permutations::Vector{Vector{Int}},
end</code></pre><p>Type representing a Lagrangian finite element. In addition to all the information provided by a <code>ReferenceFE</code>, this type also provides &quot;node-based&quot; information in the following fields:</p><ul><li><code>face_own_nodeids::Vector{Vector{Int}}</code>: nodes owned by each face</li><li><code>own_nodes_permutations::Vector{Vector{Int}}</code>: permutations of the nodes when the vertices are permuted</li></ul><p>For this type</p><ul><li><code>get_dofs(reffe)</code> returns a <code>LagrangianDofBasis</code></li><li><code>get_prebasis(reffe)</code> returns a <code>MonomialBasis</code></li><li><code>ReferenceFE{N}(reffe,faceid) where N</code> returns a <code>LagrangianRefFE{N}</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L2-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.Polynomials.MonomialBasis,InplaceArrays.ReferenceFEs.LagrangianDofBasis,Array{Array{Int64,1},1},Array{Array{Int64,1},1},Vararg{Any,N} where N}} where D" href="#InplaceArrays.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.Polynomials.MonomialBasis,InplaceArrays.ReferenceFEs.LagrangianDofBasis,Array{Array{Int64,1},1},Array{Array{Int64,1},1},Vararg{Any,N} where N}} where D"><code>InplaceArrays.ReferenceFEs.LagrangianRefFE</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">LagrangianRefFE(
  polytope::Polytope{D},
  prebasis::MonomialBasis,
  dofs::LagrangianDofBasis,
  face_own_nodeids::Vector{Vector{Int}},
  own_nodes_permutations::Vector{Vector{Int}},
  reffaces...) where D</code></pre><p>Low level (inner) constructor of <code>LagrangianRefFE</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L26-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope{D},Any}} where D where T" href="#InplaceArrays.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope{D},Any}} where D where T"><code>InplaceArrays.ReferenceFEs.LagrangianRefFE</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">LagrangianRefFE(::Type{T},p::Polytope,orders) where T
LagrangianRefFE(::Type{T},p::Polytope,order::Int) where T</code></pre><p>Builds a <code>LagrangianRefFE</code> object on top of the given polytope. <code>T</code> is the type of the value of the approximation space (e.g., <code>T=Float64</code> for scalar-valued problems, <code>T=VectorValue{N,Float64}</code> for vector-valued problems with <code>N</code> components). The arguments <code>order</code> or <code>orders</code> are for the polynomial order of the resulting space, which allows isotropic or anisotropic orders respectively (provided that the cell topology allows the given anisotropic order). The argument <code>orders</code> should be an indexable collection of <code>D</code> integers (e.g., a tuple or a vector), being <code>D</code> the number of space dimensions.</p><p>In order to be able to use this function, the type of the provided polytope <code>p</code> has to implement the following additional methods. They have been implemented for <code>ExtrusionPolytope</code> in the library. They  need to be implemented for new polytope types in order to build Lagangian reference elements on top of them.</p><ul><li><a href="#InplaceArrays.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T"><code>compute_monomial_basis(::Type{T},p::Polytope,orders) where T</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_own_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>compute_own_nodes(p::Polytope,orders)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_face_orders-Tuple{InplaceArrays.ReferenceFEs.Polytope,InplaceArrays.ReferenceFEs.Polytope,Int64,Any}"><code>compute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)</code></a></li></ul><p>The following methods are also used in the construction of the <code>LagrangianRefFE</code> object. A default implementation of them is available in terms of the three previous methods. However, the user can also implement them for new polytope types increasing customization possibilities.</p><ul><li><a href="#InplaceArrays.ReferenceFEs.compute_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>compute_nodes(p::Polytope,orders)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_own_nodes_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>compute_own_nodes_permutations(p::Polytope, interior_nodes)</code></a></li><li><a href="#InplaceArrays.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T"><code>compute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L162-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T" href="#InplaceArrays.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T"><code>InplaceArrays.ReferenceFEs.compute_monomial_basis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute_monomial_basis(::Type{T},p::Polytope,orders) where T -&gt; MonomialBasis</code></pre><p>Returns the monomial basis of value type <code>T</code> and order per direction described by <code>orders</code> on top of the polytope <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L229-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.compute_own_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}" href="#InplaceArrays.ReferenceFEs.compute_own_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>InplaceArrays.ReferenceFEs.compute_own_nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute_own_nodes(p::Polytope{D},orders) where D -&gt; Vector{Point{D,Float64}}</code></pre><p>Returns the coordinates of the nodes owned by the interior of the polytope associated with a Lagrangian space with the order per direction described by <code>orders</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L239-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.compute_face_orders-Tuple{InplaceArrays.ReferenceFEs.Polytope,InplaceArrays.ReferenceFEs.Polytope,Int64,Any}" href="#InplaceArrays.ReferenceFEs.compute_face_orders-Tuple{InplaceArrays.ReferenceFEs.Polytope,InplaceArrays.ReferenceFEs.Polytope,Int64,Any}"><code>InplaceArrays.ReferenceFEs.compute_face_orders</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)</code></pre><p>Returns a vector or a tuple with the order per direction at the face <code>face</code> of the polytope <code>p</code> when restricting the order per direction <code>orders</code> to this face. <code>iface</code> is the face id of <code>face</code> in the numeration restricted to the face dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L249-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.compute_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}" href="#InplaceArrays.ReferenceFEs.compute_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>InplaceArrays.ReferenceFEs.compute_nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute_nodes(p::Polytope,orders)</code></pre><p>When called</p><pre><code class="language-none">node_coords, face_own_nodeids = compute_nodes(p,orders)</code></pre><p>Returns <code>node_coords</code>, the nodal coordinates of all the Lagrangian nodes associated with the order per direction <code>orders</code>, and <code>face_own_nodeids</code>, being a vector of vectors indicating which nodes are owned by each of the faces of the polytope <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L260-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.compute_own_nodes_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}" href="#InplaceArrays.ReferenceFEs.compute_own_nodes_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}"><code>InplaceArrays.ReferenceFEs.compute_own_nodes_permutations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute_own_nodes_permutations(
  p::Polytope, own_nodes_coordinates) -&gt; Vector{Vector{Int}}</code></pre><p>Returns a vector of vectors with the permutations of the nodes owned by the interior of the polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L275-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T" href="#InplaceArrays.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T"><code>InplaceArrays.ReferenceFEs.compute_lagrangian_reffaces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T</code></pre><p>Returns a tuple of length <code>D</code> being the number of space dimensions. The entry <code>d+1</code> of this tuple contains a vector of <code>LagrangianRefFE</code> one for each face of dimension <code>d</code> on the boundary of the polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L286-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_node_coordinates-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}" href="#InplaceArrays.ReferenceFEs.get_node_coordinates-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>InplaceArrays.ReferenceFEs.get_node_coordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_node_coordinates(reffe::LagrangianRefFE) -&gt; Vector{Point{D,Float64}}</code></pre><p>Returns the nodal coordinates of the underlying <code>LagrangianDofBasis</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L71-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_dof_to_node-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}" href="#InplaceArrays.ReferenceFEs.get_dof_to_node-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>InplaceArrays.ReferenceFEs.get_dof_to_node</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_dof_to_node(reffe::LagrangianRefFE) -&gt; Vector{Int}</code></pre><p>Returns the field <code>dof_to_node</code> of the underlying <code>LagrangianDofBasis</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L78-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_dof_to_comp-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}" href="#InplaceArrays.ReferenceFEs.get_dof_to_comp-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>InplaceArrays.ReferenceFEs.get_dof_to_comp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_dof_to_comp(reffe::LagrangianRefFE) -&gt; Vector{Int}</code></pre><p>Returns the field <code>dof_to_comp</code> of the underlying <code>LagrangianDofBasis</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L85-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.get_node_and_comp_to_dof-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}" href="#InplaceArrays.ReferenceFEs.get_node_and_comp_to_dof-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}"><code>InplaceArrays.ReferenceFEs.get_node_and_comp_to_dof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_node_and_comp_to_dof(reffe::LagrangianRefFE) -&gt; Vector</code></pre><p>Returns the field <code>node_and_comp_to_dof</code> of the underlying <code>LagrangianDofBasis</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/LagrangianRefFEs.jl#L92-L96">source</a></section><h3><a class="nav-anchor" id="Serendipity-reference-elements-1" href="#Serendipity-reference-elements-1">Serendipity reference elements</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.SerendipityRefFE" href="#InplaceArrays.ReferenceFEs.SerendipityRefFE"><code>InplaceArrays.ReferenceFEs.SerendipityRefFE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SerendipityRefFE(::Type{T},p::Polytope,order::Int) where T</code></pre><p>Returns an instance of <code>LagrangianRefFE</code>, whose underlying approximation space is the serendipity space of order <code>order</code>. Implemented for order from 1 to 4. The type of the polytope <code>p</code> has to implement all the queries detailed in the constructor <a href="#InplaceArrays.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope{D},Any}} where D where T"><code>LagrangianRefFE(::Type{T},p::Polytope{D},orders) where {T,D}</code></a> plus this additional method:</p><ul><li><a href="#InplaceArrays.ReferenceFEs.is_serendipity_compatible-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>is_serendipity_compatible(p::Polytope)</code></a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using InplaceArrays.ReferenceFEs

order = 2
reffe = SerendipityRefFE(Float64,QUAD,order)

println( num_dofs(reffe) )

# output
8
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/SerendipityRefFEs.jl#L2-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InplaceArrays.ReferenceFEs.is_serendipity_compatible-Tuple{InplaceArrays.ReferenceFEs.Polytope}" href="#InplaceArrays.ReferenceFEs.is_serendipity_compatible-Tuple{InplaceArrays.ReferenceFEs.Polytope}"><code>InplaceArrays.ReferenceFEs.is_serendipity_compatible</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_serendipity_compatible(p::Polytope) -&gt; Bool</code></pre><p>Returns <code>true</code> if the polytope <code>p</code> is compatible with the serendipity space (i.e., it is a n-cube). This method is implemented for <code>ExtrusionPolytope</code>, and should be implemented by new polytope types if they are to be used to build serendipity spaces.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fverdugo/InplaceArrays.jl/blob/4dd70ec01e8fe817b2a922a289107ad061151036/src/ReferenceFEs/SerendipityRefFEs.jl#L34-L41">source</a></section><footer><hr/><a class="previous" href="../Polynomials/"><span class="direction">Previous</span><span class="title">Gridap.Polynomials</span></a></footer></article></body></html>
