var documenterSearchIndex = {"docs":
[{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"CurrentModule = InplaceArrays.Fields","category":"page"},{"location":"Fields/#Gridap.Fields-1","page":"Gridap.Fields","title":"Gridap.Fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"Fields","category":"page"},{"location":"Fields/#InplaceArrays.Fields","page":"Gridap.Fields","title":"InplaceArrays.Fields","text":"This module provides:\n\nAn interface for physical fields, basis of physical fields and related objects.\nHelpers functions to work with fields and arrays of fields.\nHelpers functions to create lazy operation trees from fields and arrays of fields\n\nThe exported names are:\n\nField\nPoint\napply_kernel_to_field\napply_to_field_array\nattachmap\ncompose\ncurl\ndivergence\nevaluate\nevaluate!\nevaluate_field\nevaluate_field!\nevaluate_field_array\nevaluate_fields\nevaluate_fields!\nfield_array_cache\nfield_array_gradient\nfield_cache\nfield_caches\nfield_gradient\nfield_gradients\nfield_return_type\nfield_return_types\ngrad2curl\ngradient\ngradient_type\nintegrate\nlaplacian\nlincomb\ntest_array_of_fields\ntest_field\nvarinner\nΔ\nε\n∇\n\n\n\n\n\n","category":"module"},{"location":"Fields/#Interface-1","page":"Gridap.Fields","title":"Interface","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"Field\nPoint\nevaluate_field!(cache,f,x)\nfield_cache(f,x)\nfield_gradient(f)\nfield_return_type(f,x)\nevaluate_gradient!(cache,f,x)\ngradient_cache(f,x)\nevaluate_hessian!(cache,f,x)\nhessian_cache(f,x)\ntest_field","category":"page"},{"location":"Fields/#InplaceArrays.Fields.Field","page":"Gridap.Fields","title":"InplaceArrays.Fields.Field","text":"abstract type Field <: Kernel\n\nAbstract type representing physical fields, bases of fields, and other related objects.  These different cases are distinguished by the return value obtained when evaluating them. E.g., a physical field returns a vector of values when evaluated at a vector of points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThe following functions need to be overloaded:\n\nevaluate_field!(cache,f,x)\nfield_cache(f,x)\n\nThe following functions can be also provided optionally\n\nfield_gradient(f)\nfield_return_type(f,x)\n\nMoreover, if the field_gradient(f) is not provided, a default implementation that uses the following functions will be used.\n\nevaluate_gradient!(cache,f,x)\ngradient_cache(f,x)\n\nIn order to be able to call field_gradient again on the resulting object the following methods have to be provided\n\nevaluate_hessian!(cache,f,x)\nhessian_cache(f,x)\n\nThese four methods are only designed to be called by the default implementation of field_gradient(f) and thus cannot be assumed that they are available for an arbitrary field. For this reason, these functions are not exported. The general way of evaluating a gradient of a field is to build the gradient with field_gradient(f) and evaluating the resulting object. For evaluating the hessian, use two times field_gradient.\n\nThe interface can be tested with\n\ntest_field\n\nMost of the functionality implemented in terms of this interface relies in duck typing (this is why all functions in the interface have the word \"field\").  Thus, it is not strictly needed to work with types that inherit from Field. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Field. For instance, a default implementation is available for numbers, which behave like \"constant\" fields, or arrays of numbers, which behave like \"constant\" bases of fields.  However, we recommend that new types inherit from Field.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#InplaceArrays.Fields.Point","page":"Gridap.Fields","title":"InplaceArrays.Fields.Point","text":"const Point{D,T} = VectorValue{D,T}\n\nType representing a point of D dimensions with coordinates of type T. Fields are evaluated at vectors of Point objects.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field!","text":"evaluate_field!(cache, f, x)\n\n\nReturns an array containing the values of evaluating the field f at the vector of points x by (possibly) using the scratch data in the cache object.  The returned value is  an array,  for which the length of the first axis is length(x), i.e., the number of points where the field has been evaluated.E.g., a physical field returns a vector of np values when evaluated at a vector of np points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThis choice is made\n\nfor performance reasons when integrating fields (i.e., adding contributions at different points) since the added values are closer in memory with this layout.\nIn order to simplify operations between field objects. E.g., the result of evaluating a physical field and a basis of nffields at a vector of np points (which leads to a vector and a matrix of size (np,) and (np,nf) respectively)  can be conveniently added with the broadcasted sum .+ operator.\n\nThe cache object is computed with the field_cache function.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_cache","text":"field_cache(f, x)\n\n\nReturns the cache object needed to evaluate field f at the vector of points x.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_gradient-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_gradient","text":"field_gradient(f)\n\n\nReturns another field that represents the gradient of the given one\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_return_type-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_return_type","text":"field_return_type(f, x)\n\n\nComputes the type obtained when evaluating field f at point x. It returns typeof(evaluate_field(f,x)) by default.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_gradient!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_gradient!","text":"evaluate_gradient!(cache, f, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient_cache","text":"gradient_cache(cache, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_hessian!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_hessian!","text":"evaluate_hessian!(cache, f, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.hessian_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.hessian_cache","text":"hessian_cache(cache, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.test_field","page":"Gridap.Fields","title":"InplaceArrays.Fields.test_field","text":"test_field(\n  f,\n  x::AbstractVector{<:Point},\n  v::AbstractArray,cmp=(==);\n  grad=nothing,\n  hessian=nothing)\n\nFunction used to test the field interface. v is an array containing the expected result of evaluating the field f at the vector of points x. The comparison is performed using  the cmp function. For fields objects that support the field_gradient function, the key-word argument grad can be used. It should contain the result of evaluating field_gradient(f) at x. Idem for hessian. The checks are performed with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Helper-functions-using-fields-1","page":"Gridap.Fields","title":"Helper functions using fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field(f,x)\nevaluate(f::Field,x)\nevaluate!(cache,f::Field,x)\ngradient(f::Field)\n∇\ngradient_type","category":"page"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field","text":"evaluate_field(f, x)\n\n\nEvaluates the field f at the vector of points x by creating a temporary cache internally. Equivalent to \n\nc = field_cache(f,x)\nevaluate_field!(c,f,x)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate-Tuple{InplaceArrays.Fields.Field,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate","text":"evaluate(f::Field,x)\n\nEquivalent to \n\nevaluate_field(f,x)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use evaluate_field instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate!-Tuple{Any,InplaceArrays.Fields.Field,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate!","text":"evaluate!(cache,f::Field,x)\n\nEquivalent to \n\nevaluate_field!(cache,f,x)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use evaluate_field! instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient-Tuple{InplaceArrays.Fields.Field}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient","text":"gradient(f::Field)\n\nEquivalent to\n\nfield_gradient(f)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use field_gradient instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.∇","page":"Gridap.Fields","title":"InplaceArrays.Fields.∇","text":"const ∇ = gradient\n\nAlias for the gradient function.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#InplaceArrays.Fields.gradient_type","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient_type","text":"gradient_type(::Type{T},x::Point) where T\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Working-with-several-fields-at-once-1","page":"Gridap.Fields","title":"Working with several fields at once","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"field_return_types(f::Tuple,x)\nfield_caches(f::Tuple,x)\nevaluate_fields(f::Tuple,x)\nevaluate_fields!(cf::Tuple,f::Tuple,x)\nfield_gradients(a,b...)\ngradient_all(a,b...)\nevaluate_all(f::Tuple,x)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.field_return_types-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_return_types","text":"field_return_types(f::Tuple,x) -> Tuple\n\nComputes a tuple with the return types of the fields in the tuple f when evaluated at the vector of points x\n\nEquivalent to\n\ntuple(( field_return_type(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_caches-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_caches","text":"field_caches(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((field_cache(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_fields-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_fields","text":"evaluate_fields(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_fields(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_fields!-Tuple{Tuple,Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_fields!","text":"evaluate_fields!(cf::Tuple,f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_fields!(ci,fi,x) for (ci,fi) in zip(c,f))...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_gradients-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_gradients","text":"field_gradients(b...) -> Tuple\n\nEquivalent to\n\nmap(field_gradient,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient_all-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient_all","text":"gradient_all(b...) -> Tuple\n\nEquivalent to\n\nmap(gradient,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_all-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_all","text":"evaluate_all(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Applying-kernels-to-fields-1","page":"Gridap.Fields","title":"Applying kernels to fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"apply_kernel_to_field(k,f...)\napply_kernel_gradient(k,f...)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.apply_kernel_to_field-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_kernel_to_field","text":"apply_kernel_to_field(k,f...) -> Field\n\nReturns a field obtained by applying the kernel k to the  values of the fields in f. That is, the returned field evaluated at a vector of points x provides the value obtained by applying kernel k to the values of the fields f at the vector of points x. Formally, the resulting field at a  vector of points  x is defined as\n\nfx = evaluate_fields(f,x)\napply_kernel(k,fx...)\n\nIn order to be able to call the field_gradient function of the resulting field, one needs to define the gradient operator associated with the underlying kernel. This is done by adding a new method to apply_kernel_gradient(k,f...) for each kernel type.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.apply_kernel_gradient-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_kernel_gradient","text":"apply_kernel_gradient(k,f...)\n\nReturns a field representing the gradient of the field obtained with\n\napply_kernel_to_field(k,f...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Working-with-arrays-of-fields-1","page":"Gridap.Fields","title":"Working with arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field_array(a::AbstractArray,x::AbstractArray)\nevaluate(::AbstractArray{<:Field},::AbstractArray)\nfield_array_gradient(a::AbstractArray)\ngradient(::AbstractArray{<:Field})\nfield_array_cache(a::AbstractArray,x::AbstractArray)\ntest_array_of_fields","category":"page"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field_array-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field_array","text":"evaluate_field_array(f::AbstractArray,x::AbstractArray) -> AbstractArray\n\nEvaluates the fields in the array f at all the vector of points in the  array of vector of points x and returns the result as a lazy array.\n\nThe result is numerically equivalent to \n\nmap(evaluate_field,a,x)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate-Tuple{AbstractArray{#s5,N} where N where #s5<:InplaceArrays.Fields.Field,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate","text":"evaluate(a::AbstractArray{<:Field},x::AbstractArray)\n\nEquivalent to \n\nevaluate_field_array(a,x)\n\nBut only for arrays a whose element type inherits from Field. If this is not the case, use evaluate_field_array(a,x) instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_array_gradient-Tuple{AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_array_gradient","text":"field_array_gradient(a::AbstractArray)\n\nReturns an array containing the gradients of the fields in the array a. Numerically equivalent to \n\nmap(field_gradient,a)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient-Tuple{AbstractArray{#s5,N} where N where #s5<:InplaceArrays.Fields.Field}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient","text":"gradient(f::AbstractArray{<:Field})\n\nEquivalent to \n\nfield_array_gradient(f)\n\nbut only for arrays whose element type is <:Field. Use function field_array_gradient otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_array_cache-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_array_cache","text":"field_array_cache(a::AbstractArray,x::AbstractArray) -> Tuple\n\nReturns the caches needed to perform the following iteration\n\nca, cfi, cx = field_array_cache(a,x)\n\nfor i in length(a)\n  fi = getindex!(ca,a,i)\n  xi = getindex!(cx,x,i)\n  fxi = evaluate!(cfi,fi,xi)\nend\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.test_array_of_fields","page":"Gridap.Fields","title":"InplaceArrays.Fields.test_array_of_fields","text":"function test_array_of_fields(\n  a::AbstractArray,\n  x::AbstractArray,\n  v::AbstractArray,\n  cmp::Function=(==);\n  grad = nothing)\n\nFunction to test an array of fields a. The array v is the expected result when calling  evaluate_field_array(a,x). The entries in the computed array and the expected one are compared with the cmp function. The key-word argument grad is optional. If present, it should contain the expected result of\n\n∇a = field_array_gradient(a)\nevaluate_field_array(∇a,x)\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Working-with-several-arrays-of-fields-at-once-1","page":"Gridap.Fields","title":"Working with several arrays of fields at once","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field_arrays(f::Tuple,x::AbstractArray)\nfield_array_gradients(f...)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field_arrays-Tuple{Tuple,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field_arrays","text":"evaluate_field_arrays(f::Tuple,x::AbstractArray) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_field_array(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_array_gradients-Tuple","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_array_gradients","text":"field_array_gradients(f...)\n\nEquivalent to \n\nmap(field_array_gradient,f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Applying-kernels-to-arrays-of-fields-1","page":"Gridap.Fields","title":"Applying kernels to arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"apply_to_field_array(k,f::AbstractArray...)\nkernel_evaluate(k,x,f...)\napply_gradient(k,f...)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.apply_to_field_array-Tuple{Any,Vararg{AbstractArray,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_to_field_array","text":"apply_to_field_array(k,f::AbstractArray...)\n\nReturns an array of fields numerically equivalent to\n\nmap( (x...) -> apply_kernel_to_field(k,x...), f )\n\nThe evaluation and the computation of the gradient of the resulting arrays can be optimized for particular kernels by adding new methods to the kernel_evaluate and  apply_gradient functions respectively.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.kernel_evaluate-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.kernel_evaluate","text":"kernel_evaluate(k,x,f...)\n\nThis function returns by default the array obtained with\n\ng = apply_to_field_array(k,f...)\nevaluate_field_array(g,x)\n\nHowever, it can be rewritten for specific kernels in order to improve performance and simplify the underlying operation tree associated in the returned object.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.apply_gradient-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_gradient","text":"apply_gradient(k,f...)\n\nBy default, it returns the array obtained as\n\na = apply(k,f...)\nfield_array_gradient(a)\n\nHowever, it can be rewritten for specific kernels in order to improve performance and simplify the underlying operation tree associated in the returned object.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Operations-on-fields-and-arrays-of-fields-1","page":"Gridap.Fields","title":"Operations on fields and arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"compose(g::Function,f...)\ncompose(g::Function,f::AbstractArray...)\nlincomb(a::Field,b::AbstractVector)\nlincomb(a::AbstractArray,b::AbstractArray)\nvarinner(a,b)\nvarinner(a::AbstractArray,b::AbstractArray)\nattachmap(f,phi)\nattachmap(f::AbstractArray,phi::AbstractArray)\nintegrate(f,x,w,j)\nintegrate(f::AbstractArray,x,w,j)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.compose-Tuple{Function,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.compose","text":"compose(g::Function,f...)\n\nReturns a new field obtained by composition of function g and the fields f. The value of the resulting field at a vector of points x is numerically equivalent to\n\nfx = evaluate_fields(f,x)\napply_kernel(bcast(g), fx...)\n\nThe gradient of the resulting field evaluated at a vector of points x is equivalent to\n\nfx = evaluate_fields(f,x)\napply_kernel(bcast(gradient(g)), fx...)\n\nNote that it is needed to overload gradient(::typeof(g)) for the given function g in order to be able to compute the gradient.\n\nAs in function apply_kernel_to_field if any of the inputs in f is a number or an array instead of a field it will be treated as a \"constant field\".\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.compose-Tuple{Function,Vararg{AbstractArray,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.compose","text":"compose(g::Function,f::AbstractArray...)\n\nReturns an array of fields numerically equivalent to\n\nmap( (x...)->compose(g,x...), f...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.lincomb-Tuple{InplaceArrays.Fields.Field,AbstractArray{T,1} where T}","page":"Gridap.Fields","title":"InplaceArrays.Fields.lincomb","text":"lincomb(a::Field,b::AbstractVector)\n\nReturns a field obtained by the \"linear combination\" of the value of the field basis a and the coefficient vector b.  The value of the resulting field evaluated at a vector of points x is defined as\n\nax = evaluate(a,x)\nax*b\n\nOn the other hand, the gradient of the resulting field is defined as\n\n∇ax = evaluate(gradient(a),x)\n∇ax*b\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.lincomb-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.lincomb","text":"lincomb(a::AbstractArray{<:Field},b::AbstractArray)\n\nReturns an array of fields numerically equivalent to\n\nmap(lincomb,a,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.varinner-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.varinner","text":"varinner(a,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.varinner-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.varinner","text":"varinner(a::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.attachmap-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.attachmap","text":"attachmap(f,phi)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.attachmap-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.attachmap","text":"attachmap(f::AbstractArray,phi::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.integrate-NTuple{4,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.integrate","text":"integrate(f,x,w,j)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.integrate-Tuple{AbstractArray,Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.integrate","text":"integrate(f::AbstractArray,x,w,j)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Differential-operators-1","page":"Gridap.Fields","title":"Differential operators","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"In addition to the gradient function already discussed, the following differential operators are defined.","category":"page"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"divergence(f)\nsymmetric_gradient(f)\nε\ncurl(f)\ngrad2curl(f)\nlaplacian(f)\nΔ","category":"page"},{"location":"Fields/#InplaceArrays.Fields.divergence-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.divergence","text":"divergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.symmetric_gradient-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.symmetric_gradient","text":"symmetric_gradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.ε","page":"Gridap.Fields","title":"InplaceArrays.Fields.ε","text":"const ε = symmetric_gradient\n\nAlias for the symmetric gradient\n\n\n\n\n\n","category":"function"},{"location":"Fields/#InplaceArrays.Fields.curl-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.curl","text":"curl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.grad2curl-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.grad2curl","text":"grad2curl(∇f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.laplacian-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.laplacian","text":"laplacian(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.Δ","page":"Gridap.Fields","title":"InplaceArrays.Fields.Δ","text":"const Δ = laplacian\n\nAlias for the laplacian function\n\n\n\n\n\n","category":"function"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"A fancy way of typing the differential operators is via the nabla object defined in the library.","category":"page"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"(*)(::typeof(∇),f)\nouter(::typeof(∇),f)\nouter(f,::typeof(∇))\ncross(::typeof(∇),f)","category":"page"},{"location":"Fields/#Base.:*-Tuple{typeof(InplaceArrays.Fields.gradient),Any}","page":"Gridap.Fields","title":"Base.:*","text":"∇*f\n\nEquivalent to\n\ndivergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.TensorValues.outer-Tuple{typeof(InplaceArrays.Fields.gradient),Any}","page":"Gridap.Fields","title":"InplaceArrays.TensorValues.outer","text":"outer(∇,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.TensorValues.outer-Tuple{Any,typeof(InplaceArrays.Fields.gradient)}","page":"Gridap.Fields","title":"InplaceArrays.TensorValues.outer","text":"outer(f,∇)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n","category":"method"},{"location":"Fields/#LinearAlgebra.cross-Tuple{typeof(InplaceArrays.Fields.gradient),Any}","page":"Gridap.Fields","title":"LinearAlgebra.cross","text":"cross(∇,f)\n\nEquivalent to\n\ncurl(f)\n\n\n\n\n\n","category":"method"},{"location":"Inference/#","page":"Gridap.Inference","title":"Gridap.Inference","text":"CurrentModule = InplaceArrays.Inference","category":"page"},{"location":"Inference/#Gridap.Inference-1","page":"Gridap.Inference","title":"Gridap.Inference","text":"","category":"section"},{"location":"Inference/#","page":"Gridap.Inference","title":"Gridap.Inference","text":"Inference\nreturn_type(f::Function,::Any...)\nreturn_type_broadcast\ntestargs\ntestargs_broadcast\ntestvalue\ntestvalues","category":"page"},{"location":"Inference/#InplaceArrays.Inference","page":"Gridap.Inference","title":"InplaceArrays.Inference","text":"This module provides a set of helper function to safely infer return types of functions.\n\nIn Gridap, we rely as less as possible in type inference. But, when needed, we adopt the following mechanism in order to compute returned types. We do not rely on the Base._return_type function.\n\nThis module exports following functions:\n\nreturn_type\nreturn_type_broadcast\ntestargs\ntestargs_broadcast\ntestvalue\ntestvalues\n\n\n\n\n\n","category":"module"},{"location":"Inference/#InplaceArrays.Inference.return_type-Tuple{Function,Vararg{Any,N} where N}","page":"Gridap.Inference","title":"InplaceArrays.Inference.return_type","text":"return_type(f::Function, Ts::Vararg{Any,N} where N) -> DataType\n\n\nReturns the type returned by function f when called with arguments of the types in Ts.\n\nThe underlying implementation uses the function testargs to generate some test values in order to call the function and determine the returned type. This mechanism does not use Base._return_type. One of the advantages is that the given function f is called, and thus, meaningful error messages will be displayed if there is any error in f. \n\n\n\n\n\n","category":"method"},{"location":"Inference/#InplaceArrays.Inference.return_type_broadcast","page":"Gridap.Inference","title":"InplaceArrays.Inference.return_type_broadcast","text":"return_type_broadcast(f::Function,Ts::DataType...) -> DataType\n\nLike return_type, but when function f is used in a broadcast operation.\n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testargs","page":"Gridap.Inference","title":"InplaceArrays.Inference.testargs","text":"testargs(f::Function,Ts::DataType...) -> Tuple\n\nReturns a tuple with valid arguments of the types in Ts in order to call function f. It defaults to testvalues(Ts...), see the testvalues function. The user can overload the testargs function for particular functions if the default test arguments are not in the domain of the function and a DomainError is raised.\n\nExamples\n\nFor the following function, the default test argument (which is a zero) is not in the domain. We can overload the testargs function to provide a valid test argument.\n\nusing InplaceArrays.Inference\nimport InplaceArrays.Inference: testargs\nfoo(x) = sqrt(x-1)\ntestargs(::typeof(foo),T::DataType) = (one(T),)\nreturn_type(foo, Int)\n# output\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testargs_broadcast","page":"Gridap.Inference","title":"InplaceArrays.Inference.testargs_broadcast","text":"testargs_broadcast(f, Ts)\n\n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testvalue","page":"Gridap.Inference","title":"InplaceArrays.Inference.testvalue","text":"testvalue(::Type{T}) where T\n\nReturns an arbitrary instance of type T. It defaults to zero(T) for non-array types and to an empty array for array types. This function is used to compute the default test arguments in testargs. It can be overloaded for new types T if zero(T) does not makes sense. \n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testvalues","page":"Gridap.Inference","title":"InplaceArrays.Inference.testvalues","text":"testvalues(Ts::DataType...) -> Tuple\n\nReturns a tuple with test values for each of the types in Ts. Equivalent to map(testvalue,Ts).\n\n\n\n\n\n","category":"function"},{"location":"Gridap/#Gridap-1","page":"Gridap","title":"Gridap","text":"","category":"section"},{"location":"Gridap/#","page":"Gridap","title":"Gridap","text":"InplaceArrays","category":"page"},{"location":"Gridap/#InplaceArrays","page":"Gridap","title":"InplaceArrays","text":"Gridap, grid-based approximation of PDEs in the Julia programming language\n\nThis module provides rich set of tools for the numerical solution of PDE, mainly based on finite element methods.\n\nThe module is structured in the following sub-modules:\n\nInplaceArrays.Helpers\nInplaceArrays.Inference\nInplaceArrays.TensorValues\nInplaceArrays.Arrays\nInplaceArrays.Fields\nInplaceArrays.Polynomials\nInplaceArrays.ReferenceFEs\n\nThe exported names are:\n\n\n\n\n\n","category":"module"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"CurrentModule = InplaceArrays.ReferenceFEs","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs-1","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"ReferenceFEs","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs","text":"The exported names are\n\nDof\nExtrusionPolytope\nGenericRefFE\nHEX\nHEX_AXIS\nINVALID_PERM\nLagrangianDofBasis\nLagrangianRefFE\nPYRAMID\nPolytope\nQUAD\nReferenceFE\nSEGMENT\nSerendipityRefFE\nTET\nTET_AXIS\nTRI\nVERTEX\nWEDGE\ncompute_face_orders\ncompute_lagrangian_reffaces\ncompute_monomial_basis\ncompute_nodes\ncompute_own_nodes\ncompute_own_nodes_permutations\ncompute_shapefuns\ndof_cache\ndof_return_type\nevaluate_dof\nevaluate_dof!\nevaluate_dof_array\nget_dimrange\nget_dof_to_comp\nget_dof_to_node\nget_dofs\nget_edge_tangents\nget_face_own_dofids\nget_facedims\nget_faces\nget_facet_normals\nget_facet_orientations\nget_node_and_comp_to_dof\nget_node_coordinates\nget_offset\nget_offsets\nget_own_dofs_permutations\nget_polytope\nget_prebasis\nget_shapefuns\nget_vertex_coordinates\nget_vertex_permutations\nget_vtkid\nget_vtknodes\nnum_dims\nnum_dofs\nnum_edges\nnum_faces\nnum_facets\nnum_vertices\ntest_dof\ntest_polytope\ntest_reference_fe\n\n\n\n\n\n","category":"module"},{"location":"ReferenceFEs/#Polytopes-1","page":"Gridap.ReferenceFEs","title":"Polytopes","text":"","category":"section"},{"location":"ReferenceFEs/#Interface-1","page":"Gridap.ReferenceFEs","title":"Interface","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"Polytope\nget_faces(p::Polytope)\nget_dimrange(p::Polytope)\nPolytope{D}(p::Polytope,Dfaceid::Integer) where D\nget_vertex_coordinates(p::Polytope)\n(==)(a::Polytope{D},b::Polytope{D}) where D\nget_edge_tangents(p::Polytope)\nget_facet_normals(p::Polytope)\nget_facet_orientations(p::Polytope)\nget_vertex_permutations(p::Polytope)\nget_vtkid(p::Polytope)\nget_vtknodes(p::Polytope)\ntest_polytope(p::Polytope{D};optional::Bool) where D\nnum_dims(::Polytope)\nnum_faces(p::Polytope)\nnum_faces(p::Polytope,dim::Integer)\nnum_facets(p::Polytope)\nnum_edges(p::Polytope)\nnum_vertices(p::Polytope)\nget_facedims(p::Polytope)\nget_offsets(p::Polytope)\nget_offset(p::Polytope,d::Integer)\nget_faces(p::Polytope,dimfrom::Integer,dimto::Integer)","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.Polytope","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.Polytope","text":"abstract type Polytope{D}\n\nAbstract type representing a polytope (i.e., a polyhedron in arbitrary dimensions). D is the environment dimension (typically, 0, 1, 2, or 3). This type parameter is needed since there are functions in the  Polytope interface that return containers with Point{D} objects. We adopt the usual nomenclature for polytope-related objects. All objects in a polytope (from vertices to the polytope itself) are called n-faces or simply faces. The notation n-faces is used only when it is needed to refer to the object dimension n. Otherwise we simply use face. In addition, we say\n\nvertex (pl. vertices): for 0-faces\nedge: for 1-faces\nfacet: for (D-1)-faces\n\nThe Polytope interface is defined by overloading the following functions\n\nget_faces(p::Polytope)\nget_dimrange(p::Polytope)\nPolytope{N}(p::Polytope,faceid::Integer) where N\nget_vertex_coordinates(p::Polytope)\n(==)(a::Polytope{D},b::Polytope{D}) where D\n\nAnd optionally these ones:\n\nget_edge_tangents(p::Polytope)\nget_facet_normals(p::Polytope)\nget_facet_orientations(p::Polytope)\nget_vertex_permutations(p::Polytope)\nget_vtkid(p::Polytope)\nget_vtknodes(p::Polytope)\n\nThe interface can be tested with the function\n\ntest_polytope\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_faces","text":"get_faces(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p the function returns a vector of vectors defining the incidence relation of the faces in the polytope.\n\nEach face in the polytope receives a unique integer id. The id 1 is assigned to the first 0-face. Consecutive increasing ids are assigned to the other 0-faces, then to 1-faces, and so on. The polytope itself receives the largest id which coincides with num_faces(p). For a face id iface, get_faces(p)[iface] is a vector of face ids, corresponding to the faces that are incident with the face labeled with iface. That is, faces that are either on its boundary or the face itself.  In this vector of incident face ids, faces are ordered by dimension, starting with 0-faces. Within each dimension, the labels are ordered in a consistent way with the polyope object for the face iface itself.\n\nExamples\n\nusing InplaceArrays.ReferenceFEs\n\nfaces = get_faces(SEGMENT)\nprintln(faces)\n\n# output\nArray{Int64,1}[[1], [2], [1, 2, 3]]\n\nThe constant SEGMENT is bound to a predefined instance of polytope that represents a segment. The face labels associated with a segment are [1,2,3], being 1 and 2 for the vertices and  3 for the segment itself. In this case, this function returns the vector of vectors [[1],[2],[1,2,3]] meaning that vertex 1 is incident with vertex 1 (idem for vertex 2), and that  the segment (id 3) is incident with the vertices 1 and 2 and the segment itself.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_dimrange-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_dimrange","text":"get_dimrange(p::Polytope) -> Vector{UnitRange{Int}}\n\nGiven a polytope p it returns a vector of ranges. The entry d+1 in this vector contains the range of face ids for the faces of dimension d.\n\nExamples\n\nusing InplaceArrays.ReferenceFEs\n\nranges = get_dimrange(SEGMENT)\nprintln(ranges)\n\n# output\nUnitRange{Int64}[1:2, 3:3]\n\nFace ids for the vertices in the segment range from 1 to 2 (2 vertices), the face ids for edges in the segment range from 3 to 3 (only one edge with id 3).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.Polytope-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}} where D","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.Polytope","text":"Polytope{N}(p::Polytope,faceid::Integer) where N\n\nReturns a Polytope{N} object representing the \"reference\" polytope of the N-face with id faceid. The value faceid refers to the numeration restricted to the dimension N (it starts with 1 for the first N-face).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_vertex_coordinates-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_vertex_coordinates","text":"get_vertex_coordinates(p::Polytope) -> Vector{Point{D,Float64}}\n\nGiven a polytope p return a vector of points representing containing the coordinates of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.:==-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.ReferenceFEs.Polytope{D}}} where D","page":"Gridap.ReferenceFEs","title":"Base.:==","text":"(==)(a::Polytope{D},b::Polytope{D}) where D\n\nReturns true if the polytopes a and b are equivalent. Otherwise, it  returns false. Note that the operator == returns false by default for polytopes of different dimensions. Thus, this function has to be overloaded only for the case of polytopes a and b of same dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_edge_tangents-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_edge_tangents","text":"get_edge_tangents(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit tangent vectors to the polytope edges.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_facet_normals-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_facet_normals","text":"get_facet_normals(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit outward normal vectors to the polytope facets.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_facet_orientations-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_facet_orientations","text":"get_facet_orientations(p::Polytope) -> Vector{Int}\n\nGiven a polytope p returns a vector of integers of length num_facets(p). Facets, whose vertices are ordered consistently with the outwards normal vector, receive value 1 in this vector. Otherwise, facets receive value -1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_vertex_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_vertex_permutations","text":"get_vertex_permutations(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p, returns a vector of vectors containing all admissible permutations of the polytope vertices. An admissible permutation is one such that, if the vertices of the polytope are re-labeled according to this permutation, the resulting polytope preserves the shape of the original one.\n\nExamples\n\nusing InplaceArrays.ReferenceFEs\n\nperms = get_vertex_permutations(SEGMENT)\nprintln(perms)\n\n# output\nArray{Int64,1}[[1, 2], [2, 1]]\n\n\nThe first admissible permutation for a segment is [1,2],i.e., the identity. The second one is [2,1], i.e., the first vertex is relabeled as 2 and the second vertex is relabeled as 1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_vtkid-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_vtkid","text":"get_vtkid(p::Polytope) -> Int\n\nGiven a polytope p, returns an integer with its vtk identifier. Overloading of this function is needed only in order to visualize the underlying polytope with Paraview.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_vtknodes-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_vtknodes","text":"get_vtknodes(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, returns a vector of integers representing a permutation of the polytope vertices required to relabel the vertices according the criterion adopted in Paraview. Overloading of this function is needed only in order to visualize the underlying polytope with Paraview.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.test_polytope-Union{Tuple{InplaceArrays.ReferenceFEs.Polytope{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.test_polytope","text":"test_polytope(p::Polytope{D}; optional::Bool=false) where D\n\nFunction that stresses out the functions in the Polytope interface. It tests whether the function in the polytope interface are defined for the given object, and whether they return objects of the expected type. With optional=false (the default), only the mandatory functions are checked. With optional=true, the optional functions are also tested except get_vtkid  and get_vtknodes.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_dims-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_dims","text":"num_dims(::Type{<:Polytope{D}}) where D\nnum_dims(p::Polytope{D}) where D\n\nReturns D. \n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_faces","text":"num_faces(p::Polytope)\n\nReturns the total number of faces in polytope p (from vertices to the polytope itself).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_faces","text":"num_faces(p::Polytope,dim::Integer)\n\nReturns the number of faces of dimension dim in polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_facets-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_facets","text":"num_facets(p::Polytope)\n\nReturns the number of facets in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_edges-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_edges","text":"num_edges(p::Polytope)\n\nReturns the number of edges in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_vertices-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_vertices","text":"num_vertices(p::Polytope)\n\nReturns the number of vertices in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_facedims-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_facedims","text":"get_facedims(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, returns a vector indicating the dimension of each face in the polytope\n\nExamples\n\nusing InplaceArrays.ReferenceFEs\n\ndims = get_facedims(SEGMENT)\nprintln(dims)\n\n# output\n[0, 0, 1]\n\n\nThe first two faces in the segment (the two vertices) have dimension 0 and the  third face (the segment itself) has dimension 1\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_offsets-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_offsets","text":"get_offsets(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, it returns a vector of integers. The position in the d+1 entry in this vector is the offset that transforms a face id in the global numeration in the polytope to the numeration restricted to faces to dimension d.\n\nExamples\n\nusing InplaceArrays.ReferenceFEs\n\noffsets = get_offsets(SEGMENT)\nprintln(offsets)\n\n# output\n[0, 2]\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_offset-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_offset","text":"get_offset(p::Polytope,d::Integer)\n\nEquivalent to get_offsets(p)[d+1].\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_faces-Tuple{InplaceArrays.ReferenceFEs.Polytope,Integer,Integer}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_faces","text":"get_faces(p::Polytope,dimfrom::Integer,dimto::Integer) -> Vector{Vector{Int}}\n\nFor dimfrom >= dimto returns a vector that for each face of dimension dimfrom stores a vector of the ids of faces of dimension dimto on its boundary.\n\nFor dimfrom < dimto returns a vector that for each face of dimfrom stores a vector of the face ids of faces of dimension dimto that touch it.\n\nThe numerations used in this funcitons are the ones restricted to each dimension.\n\nusing InplaceArrays.ReferenceFEs\n\nedge_to_vertices = get_faces(QUAD,1,0)\nprintln(edge_to_vertices)\n\nvertex_to_edges_around = get_faces(QUAD,0,1)\nprintln(vertex_to_edges_around)\n\n# output\nArray{Int64,1}[[1, 2], [3, 4], [1, 3], [2, 4]]\nArray{Int64,1}[[1, 3], [1, 4], [2, 3], [2, 4]]\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Extrusion-polytopes-1","page":"Gridap.ReferenceFEs","title":"Extrusion polytopes","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"ExtrusionPolytope\nExtrusionPolytope(extrusion::Int...)\nPolytope(extrusion::Int...)\nHEX_AXIS\nTET_AXIS","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.ExtrusionPolytope","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.ExtrusionPolytope","text":"struct ExtrusionPolytope{D} <: Polytope{D}\n  extrusion::Point{D,Int}\n  # + private fields\nend\n\nConcrete type for polytopes that can be represented with an \"extrusion\" tuple. The underlying extrusion is available in the field extrusion. Instances of this type can be obtained with the constructors\n\nPolytope(extrusion::Int...)\nExtrusionPolytope(extrusion::Int...)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.ExtrusionPolytope-Tuple{Vararg{Int64,N} where N}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.ExtrusionPolytope","text":"ExtrusionPolytope(extrusion::Int...)\n\nGenerates an ExtrusionPolytope from the tuple extrusion. The values in extrusion are either equal to the constant HEX_AXIS or the constant TET_AXIS.\n\nExamples\n\nCreating a quadrilateral, a triangle, and a wedge\n\nusing InplaceArrays.ReferenceFEs\n\nquad = ExtrusionPolytope(HEX_AXIS,HEX_AXIS)\n\ntri = ExtrusionPolytope(TET_AXIS,TET_AXIS)\n\nwedge = ExtrusionPolytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\nprintln(quad == QUAD)\nprintln(tri == TRI)\nprintln(wedge == WEDGE)\n\n# output\ntrue\ntrue\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.Polytope-Tuple{Vararg{Int64,N} where N}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.Polytope","text":"Polytope(extrusion::Int...)\n\nEquivalent to ExtrusionPolytope(extrusion...)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.HEX_AXIS","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.HEX_AXIS","text":"Constant to be used in order to indicate a hex-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.TET_AXIS","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.TET_AXIS","text":"Constant to be used in order to indicate a tet-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Pre-defined-polytope-instances-1","page":"Gridap.ReferenceFEs","title":"Pre-defined polytope instances","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"VERTEX\nSEGMENT\nTRI\nQUAD\nTET\nHEX\nWEDGE\nPYRAMID","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.VERTEX","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.VERTEX","text":"const VERTEX = Polytope()\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.SEGMENT","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.SEGMENT","text":"const SEGMENT = Polytope(HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.TRI","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.TRI","text":"const TRI = Polytope(TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.QUAD","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.QUAD","text":"const QUAD = Polytope(HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.TET","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.TET","text":"const TET = Polytope(TET_AXIS,TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.HEX","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.HEX","text":"const HEX = Polytope(HEX_AXIS,HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.WEDGE","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.WEDGE","text":"const WEDGE = Polytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.PYRAMID","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.PYRAMID","text":"const PYRAMID = Polytope(HEX_AXIS,HEX_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Degrees-of-freedom-1","page":"Gridap.ReferenceFEs","title":"Degrees of freedom","text":"","category":"section"},{"location":"ReferenceFEs/#Interface-2","page":"Gridap.ReferenceFEs","title":"Interface","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"Dof\nevaluate_dof!(cache,dof,field)\ndof_cache(dof,field)\ndof_return_type(dof,field)\ntest_dof(dof,field,v,comp::Function)\nevaluate_dof(dof,field)\nevaluate(dof::Dof,field)","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.Dof","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.Dof","text":"abstract type Dof <: Kernel\n\nAbstract type representing a degree of freedom (DOF), a basis of DOFs, and related objects. These different cases are distinguished by the return type obtained when evaluating the Dof object on a Field object. See function evaluate_dof! for more details.\n\nThe following functions needs to be overloaded\n\ndof_cache\nevaluate_dof!\n\nThe following functions can be overloaded optionally\n\ndof_return_type\n\nThe interface is tested with\n\ntest_dof\n\nIn most of the cases it is not strictly needed that types that implement this interface inherit from Dof. However, we recommend to inherit from Dof, when possible.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.evaluate_dof!-Tuple{Any,Any,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.evaluate_dof!","text":"evaluate_dof!(cache,dof,field)\n\nEvaluates the dof dof with the field field. It can return either an scalar value or an array of scalar values depending the case. The cache object is computed with function dof_cache.\n\nWhen a mathematical dof is evaluated on a physical field, a scalar number is returned. If either the Dof object is a basis of DOFs, or the Field object is a basis of fields, or both objects are bases, then the returned object is an array of scalar numbers. The first dimensions in the resulting array are for the Dof object and the last ones for the Field object. E.g, a basis of nd DOFs evaluated at physical field returns a vector of nd entries. A basis of nd DOFs evaluated at a basis of nf fields returns a matrix of size (nd,nf).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.dof_cache-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.dof_cache","text":"dof_cache(dof,field)\n\nReturns the cache needed to call evaluate_dof!(cache,dof,field)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.dof_return_type-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.dof_return_type","text":"dof_return_type(dof,field)\n\nReturns the type for the value obtained with evaluating dof with field.\n\nIt defaults to\n\ntypeof(evaluate_dof(dof,field))\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.test_dof-Tuple{Any,Any,Any,Function}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.test_dof","text":"test_dof(dof,field,v,comp::Function=(==))\n\nTest that the Dof interface is properly implemented for object dof. It also checks if the object dof when evaluated at the field field returns the same value as v. Comparison is made with the comp function.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.evaluate_dof-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.evaluate_dof","text":"evaluate_dof(dof,field)\n\nEquivalent to\n\ncache = dof_cache(dof,field)\nevaluate_dof!(cache,dof,field)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.Fields.evaluate-Tuple{InplaceArrays.ReferenceFEs.Dof,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.Fields.evaluate","text":"evaluate(dof::Dof,field)\n\nEquivalent to evaluate_dof(dof,field).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Working-with-arrays-of-DOFs-1","page":"Gridap.ReferenceFEs","title":"Working with arrays of DOFs","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"evaluate_dof_array(dof::AbstractArray,field::AbstractArray)\nevaluate(dof::AbstractArray{<:Dof},field::AbstractArray)","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.evaluate_dof_array-Tuple{AbstractArray,AbstractArray}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.evaluate_dof_array","text":"evaluate_dof_array(dof::AbstractArray,field::AbstractArray)\n\nEvaluates the Dof objects in the array dof at the Field objects at the array field element by element.\n\nThe result is numerically equivalent to\n\nmap(evaluate_dof, dof, field)\n\nbut it is described with a more memory-friendly lazy type.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.Fields.evaluate-Tuple{AbstractArray{#s5,N} where N where #s5<:InplaceArrays.ReferenceFEs.Dof,AbstractArray}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.Fields.evaluate","text":"evaluate(dof::AbstractArray{<:Dof},field::AbstractArray)\n\nEquivalent to evaluate_dof_array(dof,field)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Lagrangian-dof-bases-1","page":"Gridap.ReferenceFEs","title":"Lagrangian dof bases","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"LagrangianDofBasis\nLagrangianDofBasis(::Type{T},nodes::Vector{<:Point}) where T","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.LagrangianDofBasis","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.LagrangianDofBasis","text":"struct LagrangianDofBasis{P,V} <: Dof\n  nodes::Vector{P}\n  dof_to_node::Vector{Int}\n  dof_to_comp::Vector{Int}\n  node_and_comp_to_dof::Vector{V}\nend\n\nType that implements a Lagrangian dof basis.\n\nFields:\n\nnodes::Vector{P} vector of points (P<:Point) storing the nodal coordinates\nnode_and_comp_to_dof::Vector{V} vector such that node_and_comp_to_dof[node][comp] returns the dof associated with node node and the component comp in the type V.\ndof_to_node::Vector{Int} vector of integers such that dof_to_node[dof] returns the node id associated with dof id dof.\ndof_to_comp::Vector{Int} vector of integers such that dof_to_comp[dof] returns the component id associated with dof id dof.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.LagrangianDofBasis-Union{Tuple{T}, Tuple{Type{T},Array{#s5,1} where #s5<:(InplaceArrays.TensorValues.MultiValue{Tuple{D},T,1,D} where T where D)}} where T","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.LagrangianDofBasis","text":"LagrangianDofBasis(::Type{T},nodes::Vector{<:Point}) where T\n\nCreates a LagrangianDofBasis for fields of value type T associated with the vector of nodal coordinates nodes.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Reference-Finite-Elements-1","page":"Gridap.ReferenceFEs","title":"Reference Finite Elements","text":"","category":"section"},{"location":"ReferenceFEs/#Interface-3","page":"Gridap.ReferenceFEs","title":"Interface","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"ReferenceFE\nnum_dofs(reffe::ReferenceFE)\nget_polytope(reffe::ReferenceFE)\nget_prebasis(reffe::ReferenceFE)\nget_dofs(reffe::ReferenceFE)\nget_face_own_dofids(reffe::ReferenceFE)\nReferenceFE{N}(reffe::ReferenceFE,nfaceid::Integer) where N\nget_own_dofs_permutations(reffe::ReferenceFE)\nINVALID_PERM\nget_shapefuns(reffe::ReferenceFE)\ncompute_shapefuns(dofs,prebasis)\nnum_dims(::ReferenceFE)\ntest_reference_fe(reffe::ReferenceFE{D}) where D","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.ReferenceFE","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.ReferenceFE","text":"abstract type ReferenceFE{D}\n\nAbstract type representing a Reference finite element. D is the underlying coordinate space dimension. We follow the Ciarlet definition. A reference finite element is defined by a polytope (cell topology), a basis of an interpolation space of top of this polytope (denoted here as the prebasis), and a basis of the dual of this space (i.e. the degrees of freedom). From this information one can compute the shape functions (i.e, the canonical basis of w.r.t. the degrees of freedom) with a simple change of basis. In addition, we also encode in this type information about how the interpolation space in a reference finite element is \"glued\" with neighbors in order to build conforming cell-wise spaces.\n\nThe ReferenceFE interface is defined by overloading these methods:\n\nnum_dofs(reffe::ReferenceFE)\nget_polytope(reffe::ReferenceFE)\nget_prebasis(reffe::ReferenceFE)\nget_dofs(reffe::ReferenceFE)\nget_face_own_dofids(reffe::ReferenceFE)\n\nand optionally these ones:\n\nReferenceFE{N}(reffe::ReferenceFE,nfaceid::Integer) where N\nget_own_dofs_permutations(reffe::ReferenceFE)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_dofs","text":"num_dofs(reffe::ReferenceFE) -> Int\n\nReturns the number of DOFs.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_polytope-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_polytope","text":"get_polytope(reffe::ReferenceFE) -> Polytope\n\nReturns the underlying polytope object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_prebasis-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_prebasis","text":"get_prebasis(reffe::ReferenceFE) -> Field\n\nReturns the underlying prebasis encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_dofs-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_dofs","text":"get_dofs(reffe::ReferenceFE) -> Dof\n\nReturns the underlying dof basis encoded in a Dof object. \n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_face_own_dofids-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_face_own_dofids","text":"get_face_own_dofids(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.ReferenceFE-Union{Tuple{N}, Tuple{InplaceArrays.ReferenceFEs.ReferenceFE,Integer}} where N","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.ReferenceFE","text":"ReferenceFE{N}(reffe::ReferenceFE,nfaceid::Integer) where N\n\nReturns a reference FE obtained by the restriction of the given one to the face with nfaceid within dimension N.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_own_dofs_permutations-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_own_dofs_permutations","text":"get_own_dofs_permutations(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\nReturns a vector of vectors indicating how the dofs owned by the reference fe have to be relabeled when the vertices of the underlying polytope are relabeled according the permutations in\n\npolytope = get_polytope(reffe)\nvertex_perms = get_vertex_permutations(polytope)\n\nThat is, if the vertices are relabeled with the permutation number iperm\n\noldvertex_to_newvertex = vertex_perms[iperm]\n\nThe dofs are relabeled as\n\nolddof_to_newdof = get_own_dofs_permutations(reffe)[iperm]\n\nNote that in some cases, a valid relabeling of the dofs for a corresponding relabeling of the vertices does not exist (i.e., lagrangian FEs with anisotropic order). For these permutations the corresponding vector in  get_own_dofs_permutations(reffe) has to be filled with the constant value INVALID_PERM.\n\nExamples\n\nRelabeling of the dofs owned by the 4-th order segment\n\nusing InplaceArrays.ReferenceFEs\n\norder = 4\nseg5 = LagrangianRefFE(Float64,SEGMENT,order)\n\nvertexperms = get_vertex_permutations(SEGMENT)\ndofperms = get_own_dofs_permutations(seg5)\n\nprintln(vertexperms)\nprintln(dofperms)\n\n# output\nArray{Int64,1}[[1, 2], [2, 1]]\nArray{Int64,1}[[1, 2, 3], [3, 2, 1]]\n\n\nNote that when the segment is flipped (the second permutation) the first owned dof becomes the third  owned dof, the second owned dof becomes the second one and the third becomes the first one as one would expect.\n\nRelabeling of the dofs owned by an anisotropic quadrilateral\n\nusing InplaceArrays.ReferenceFEs\n\norders = (2,3)\nquad12 = LagrangianRefFE(Float64,QUAD,orders)\n\nvertexperms = get_vertex_permutations(QUAD)\ndofperms = get_own_dofs_permutations(quad12)\n\nprintln(vertexperms)\nprintln(dofperms)\nprintln(INVALID_PERM)\n\n# output\nArray{Int64,1}[[1, 2, 3, 4], [1, 3, 2, 4], [2, 1, 4, 3], [2, 4, 1, 3], [3, 1, 4, 2], [3, 4, 1, 2], [4, 2, 3, 1], [4, 3, 2, 1]]\nArray{Int64,1}[[1, 2], [0, 0], [1, 2], [0, 0], [0, 0], [2, 1], [0, 0], [2, 1]]\n0\n\nNote that not all permutations are valid in this case.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.INVALID_PERM","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.INVALID_PERM","text":"Constant of type Int  used to signal that a permutation is not valid.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_shapefuns-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_shapefuns","text":"get_shapefuns(reffe::ReferenceFE) -> Field\n\nReturns the basis of shape functions (i.e. the canonical basis) associated with the reference FE. The result is encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.compute_shapefuns-Tuple{Any,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.compute_shapefuns","text":"compute_shapefuns(dofs,prebasis)\n\nHelper function used to compute the shape function basis associated with the dof basis dofs and the basis prebasis.\n\nIt is equivalent to\n\nchange = inv(evaluate(dofs,prebasis))\nchange_basis(prebasis,change)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.num_dims-Tuple{InplaceArrays.ReferenceFEs.ReferenceFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.num_dims","text":"num_dims(::Type{<:ReferenceFE{D}}) where D\nnum_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.test_reference_fe-Union{Tuple{InplaceArrays.ReferenceFEs.ReferenceFE{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.test_reference_fe","text":"test_reference_fe(reffe::ReferenceFE{D};optional::Bool=false) where D\n\nTest if the methods in the ReferenceFE interface are defined for the object reffe. If optional=false (the default) only the mandatory methods are checked. Otherwise, the optional methods are also tested.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Generic-reference-elements-1","page":"Gridap.ReferenceFEs","title":"Generic reference elements","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"GenericRefFE\nGenericRefFE(\n  polytope::Polytope{D},\n  prebasis::Field,\n  dofs::Dof,\n  facedofids::Vector{Vector{Int}};\n  shapefuns::Field,\n  ndofs::Int,\n  dofperms::Vector{Vector{Int}},\n  reffaces) where D","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.GenericRefFE","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.GenericRefFE","text":"struct GenericRefFE{D} <: ReferenceFE{D}\n  polytope::Polytope{D}\n  prebasis::Field\n  dofs::Dof\n  face_own_dofids::Vector{Vector{Int}}\n  shapefuns::Field\n  ndofs::Int\n  own_dofs_permutations::Vector{Vector{Int}}\n  reffaces\nend\n\nThis type is a materialization of the ReferenceFE interface. That is, it is a  struct that stores the values of all abstract methods in the ReferenceFE interface. This type is useful to build reference FEs from the underlying ingredients without the need to create a new type.\n\nNote that some fields in this struct are type unstable deliberately in order to simplify the type signature. Don't access them in computationally expensive functions, instead extract the required fields before and pass them to the computationally expensive function.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.GenericRefFE-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.Fields.Field,InplaceArrays.ReferenceFEs.Dof,Array{Array{Int64,1},1}}} where D","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.GenericRefFE","text":"GenericRefFE(\n  polytope::Polytope{D},\n  prebasis::Field,\n  dofs::Dof,\n  face_own_dofids::Vector{Vector{Int}};\n  shapefuns::Field,\n  ndofs::Int,\n  own_dofs_permutations::Vector{Vector{Int}},\n  reffaces) where D\n\nConstructs a GenericRefFE object with the provided data. Positional arguments are mandatory. All Key-word ones are optional.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Lagrangian-reference-elements-1","page":"Gridap.ReferenceFEs","title":"Lagrangian reference elements","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"LagrangianRefFE\nLagrangianRefFE(\n  polytope::Polytope{D},\n  prebasis::MonomialBasis,\n  dofs::LagrangianDofBasis,\n  face_own_nodeids::Vector{Vector{Int}},\n  own_nodes_permutations::Vector{Vector{Int}},\n  reffaces...) where D\nLagrangianRefFE(::Type{T},p::Polytope{D},orders) where {T,D}\ncompute_monomial_basis(::Type{T},p::Polytope,orders) where T\ncompute_own_nodes(p::Polytope,orders)\ncompute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\ncompute_nodes(p::Polytope,orders)\ncompute_own_nodes_permutations(p::Polytope, interior_nodes)\ncompute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\nget_node_coordinates(reffe::LagrangianRefFE)\nget_dof_to_node(reffe::LagrangianRefFE)\nget_dof_to_comp(reffe::LagrangianRefFE)\nget_node_and_comp_to_dof(reffe::LagrangianRefFE)","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.LagrangianRefFE","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.LagrangianRefFE","text":"struct LagrangianRefFE{D} <: ReferenceFE{D}\n  data::GenericRefFE{D}\n  face_own_nodeids::Vector{Vector{Int}}\n  own_nodes_permutations::Vector{Vector{Int}},\nend\n\nType representing a Lagrangian finite element. In addition to all the information provided by a ReferenceFE, this type also provides \"node-based\" information in the following fields:\n\nface_own_nodeids::Vector{Vector{Int}}: nodes owned by each face\nown_nodes_permutations::Vector{Vector{Int}}: permutations of the nodes when the vertices are permuted\n\nFor this type\n\nget_dofs(reffe) returns a LagrangianDofBasis\nget_prebasis(reffe) returns a MonomialBasis\nReferenceFE{N}(reffe,faceid) where N returns a LagrangianRefFE{N}\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{InplaceArrays.ReferenceFEs.Polytope{D},InplaceArrays.Polynomials.MonomialBasis,InplaceArrays.ReferenceFEs.LagrangianDofBasis,Array{Array{Int64,1},1},Array{Array{Int64,1},1},Vararg{Any,N} where N}} where D","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.LagrangianRefFE","text":"LagrangianRefFE(\n  polytope::Polytope{D},\n  prebasis::MonomialBasis,\n  dofs::LagrangianDofBasis,\n  face_own_nodeids::Vector{Vector{Int}},\n  own_nodes_permutations::Vector{Vector{Int}},\n  reffaces...) where D\n\nLow level (inner) constructor of LagrangianRefFE.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope{D},Any}} where D where T","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.LagrangianRefFE","text":"LagrangianRefFE(::Type{T},p::Polytope,orders) where T\nLagrangianRefFE(::Type{T},p::Polytope,order::Int) where T\n\nBuilds a LagrangianRefFE object on top of the given polytope. T is the type of the value of the approximation space (e.g., T=Float64 for scalar-valued problems, T=VectorValue{N,Float64} for vector-valued problems with N components). The arguments order or orders are for the polynomial order of the resulting space, which allows isotropic or anisotropic orders respectively (provided that the cell topology allows the given anisotropic order). The argument orders should be an indexable collection of D integers (e.g., a tuple or a vector), being D the number of space dimensions.\n\nIn order to be able to use this function, the type of the provided polytope p has to implement the following additional methods. They have been implemented for ExtrusionPolytope in the library. They  need to be implemented for new polytope types in order to build Lagangian reference elements on top of them.\n\ncompute_monomial_basis(::Type{T},p::Polytope,orders) where T\ncompute_own_nodes(p::Polytope,orders)\ncompute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nThe following methods are also used in the construction of the LagrangianRefFE object. A default implementation of them is available in terms of the three previous methods. However, the user can also implement them for new polytope types increasing customization possibilities.\n\ncompute_nodes(p::Polytope,orders)\ncompute_own_nodes_permutations(p::Polytope, interior_nodes)\ncompute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.compute_monomial_basis","text":"compute_monomial_basis(::Type{T},p::Polytope,orders) where T -> MonomialBasis\n\nReturns the monomial basis of value type T and order per direction described by orders on top of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.compute_own_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.compute_own_nodes","text":"compute_own_nodes(p::Polytope{D},orders) where D -> Vector{Point{D,Float64}}\n\nReturns the coordinates of the nodes owned by the interior of the polytope associated with a Lagrangian space with the order per direction described by orders.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.compute_face_orders-Tuple{InplaceArrays.ReferenceFEs.Polytope,InplaceArrays.ReferenceFEs.Polytope,Int64,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.compute_face_orders","text":"compute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nReturns a vector or a tuple with the order per direction at the face face of the polytope p when restricting the order per direction orders to this face. iface is the face id of face in the numeration restricted to the face dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.compute_nodes-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.compute_nodes","text":"compute_nodes(p::Polytope,orders)\n\nWhen called\n\nnode_coords, face_own_nodeids = compute_nodes(p,orders)\n\nReturns node_coords, the nodal coordinates of all the Lagrangian nodes associated with the order per direction orders, and face_own_nodeids, being a vector of vectors indicating which nodes are owned by each of the faces of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.compute_own_nodes_permutations-Tuple{InplaceArrays.ReferenceFEs.Polytope,Any}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.compute_own_nodes_permutations","text":"compute_own_nodes_permutations(\n  p::Polytope, own_nodes_coordinates) -> Vector{Vector{Int}}\n\nReturns a vector of vectors with the permutations of the nodes owned by the interior of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T},InplaceArrays.ReferenceFEs.Polytope,Any}} where T","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.compute_lagrangian_reffaces","text":"compute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\nReturns a tuple of length D being the number of space dimensions. The entry d+1 of this tuple contains a vector of LagrangianRefFE one for each face of dimension d on the boundary of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_node_coordinates-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_node_coordinates","text":"get_node_coordinates(reffe::LagrangianRefFE) -> Vector{Point{D,Float64}}\n\nReturns the nodal coordinates of the underlying LagrangianDofBasis.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_dof_to_node-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_dof_to_node","text":"get_dof_to_node(reffe::LagrangianRefFE) -> Vector{Int}\n\nReturns the field dof_to_node of the underlying LagrangianDofBasis.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_dof_to_comp-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_dof_to_comp","text":"get_dof_to_comp(reffe::LagrangianRefFE) -> Vector{Int}\n\nReturns the field dof_to_comp of the underlying LagrangianDofBasis.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.get_node_and_comp_to_dof-Tuple{InplaceArrays.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.get_node_and_comp_to_dof","text":"get_node_and_comp_to_dof(reffe::LagrangianRefFE) -> Vector\n\nReturns the field node_and_comp_to_dof of the underlying LagrangianDofBasis.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Serendipity-reference-elements-1","page":"Gridap.ReferenceFEs","title":"Serendipity reference elements","text":"","category":"section"},{"location":"ReferenceFEs/#","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"SerendipityRefFE\nis_serendipity_compatible(p::Polytope)","category":"page"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.SerendipityRefFE","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.SerendipityRefFE","text":"SerendipityRefFE(::Type{T},p::Polytope,order::Int) where T\n\nReturns an instance of LagrangianRefFE, whose underlying approximation space is the serendipity space of order order. Implemented for order from 1 to 4. The type of the polytope p has to implement all the queries detailed in the constructor LagrangianRefFE(::Type{T},p::Polytope{D},orders) where {T,D} plus this additional method:\n\nis_serendipity_compatible(p::Polytope)\n\nExamples\n\nusing InplaceArrays.ReferenceFEs\n\norder = 2\nreffe = SerendipityRefFE(Float64,QUAD,order)\n\nprintln( num_dofs(reffe) )\n\n# output\n8\n\n\n\n\n\n\n","category":"function"},{"location":"ReferenceFEs/#InplaceArrays.ReferenceFEs.is_serendipity_compatible-Tuple{InplaceArrays.ReferenceFEs.Polytope}","page":"Gridap.ReferenceFEs","title":"InplaceArrays.ReferenceFEs.is_serendipity_compatible","text":"is_serendipity_compatible(p::Polytope) -> Bool\n\nReturns true if the polytope p is compatible with the serendipity space (i.e., it is a n-cube). This method is implemented for ExtrusionPolytope, and should be implemented by new polytope types if they are to be used to build serendipity spaces.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CurrentModule = InplaceArrays.Arrays","category":"page"},{"location":"Arrays/#Gridap.Arrays-1","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Arrays","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays","page":"Gridap.Arrays","title":"InplaceArrays.Arrays","text":"This module provides:\n\nAn extension of the AbstractArray interface in order to properly deal with mutable caches.\nA mechanism to generate lazy arrays resulting from operations between arrays.\nA collection of concrete implementations of AbstractArray.\n\nThe exported names in this module are:\n\nCachedArray\nCachedMatrix\nCachedVector\nCompressedArray\nKernel\nLocalToGlobalArray\nTable\napply\napply_all\napply_kernel\napply_kernel!\napply_kernels!\narray_cache\narray_caches\nbcast\ncontract\nelem\ngetindex!\ngetitems!\nkernel_cache\nkernel_caches\nkernel_return_type\nkernel_return_types\nsetsize!\ntest_array\ntest_kernel\ntestitem\ntestitems\nuses_hash\n\n\n\n\n\n","category":"module"},{"location":"Arrays/#Extended-AbstractArray-interface-1","page":"Gridap.Arrays","title":"Extended AbstractArray interface","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"When implementing new array types, it can be needed some scratch data (e.g., allocating the output), when recovering an item from an array (typically if the array elements are non-isbits objects). To circumvent this, the user could provide the scratch data needed when getting an item. However, the Julia array interface does not support this approach. When calling a[i], in order to get the element with index i in array a, there is no extra argument for the scratch data. In order to solve this problem, we add new methods to the AbstractArray interface of Julia. We provide default implementations to the new methods, so that any AbstractArray can be used with the extended interface. New array implementations can overload these default implementations to improve performance. The most important among the new methods is getindex!, which allows to recover an item in the array by passing some scratch data.","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"The new methods are:","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getindex!(cache,a::AbstractArray,i...)\narray_cache(a::AbstractArray)\nuses_hash(::Type{<:AbstractArray})\ntestitem(a::AbstractArray)","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"These methods can be stressed with the following function","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"test_array","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getindex!(cache,a::AbstractArray,i...)\narray_cache(a::AbstractArray)\nuses_hash(::Type{<:AbstractArray})\ntestitem(a::AbstractArray)\ntest_array","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.getindex!","text":"getindex!(cache,a::AbstractArray,i...)\n\nReturns the item of the array a associated with index i by (possibly) using the scratch data passed in the cache object.\n\nIt defaults to\n\ngetindex!(cache,a::AbstractArray,i...) = a[i...]\n\nExamples\n\nIterating over an array using the getindex! function\n\nusing InplaceArrays.Arrays\n\na = collect(10:15)\n\ncache = array_cache(a)\nfor i in eachindex(a)\n  ai = getindex!(cache,a,i)\n  println(\"$i -> $ai\")\nend\n\n# output\n1 -> 10\n2 -> 11\n3 -> 12\n4 -> 13\n5 -> 14\n6 -> 15\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.array_cache","text":"array_cache(a::AbstractArray)\n\nReturns a cache object to be used in the getindex! function. It defaults to \n\narray_cache(a::T) where T = nothing\n\nfor types T such that uses_hash(T) == Val(false), and \n\nfunction array_cache(a::T) where T\n  hash = Dict{UInt,Any}()\n  array_cache(hash,a)\nend\n\nfor types T such that uses_hash(T) == Val(true), see the uses_hash function. In the later case, the type T should implement the following signature:\n\narray_cache(hash::Dict,a::AbstractArray)\n\nwhere we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object a has already build a cache and re-use it as follows\n\nid = objectid(a)\nif haskey(hash,id)\n  cache = hash[id] # Reuse cache\nelse\n  cache = ... # Build a new cache depending on your needs\n  hash[id] = cache # Register the cache in the hash table\nend\n\nThis mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s5} where #s5<:AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.uses_hash","text":"uses_hash(::Type{<:AbstractArray})\n\nThis function is used to specify if the type T uses the hash-based mechanism to reuse caches.  It should return either Val(true) or Val(false). It defaults to\n\nuses_hash(::Type{<:AbstractArray}) = Val(false)\n\nOnce this function is defined for the type T it can also be called on instances of T.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.testitem","text":"testitem(a::AbstractArray{T,N} where N) -> Any\n\n\nReturns an arbitrary instance of eltype(a). The default returned value is the first entry in the array if length(a)>0 and testvalue(eltype(a)) if length(a)==0 See the testvalue function.\n\nExamples\n\nusing InplaceArrays.Arrays\n\na = collect(3:10)\nai = testitem(a)\n\nb = Int[]\nbi = testitem(b)\n\n(ai, bi)\n\n# output\n(3, 0)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.test_array","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.test_array","text":"test_array(\n  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}\n\nChecks if the entries in a and b are equal using the comparison function cmp. It also stresses the new methods added to the AbstractArray interface interface.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Working-with-several-arrays-at-once-1","page":"Gridap.Arrays","title":"Working with several arrays at once","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getitems!\narray_caches\ntestitems","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.getitems!","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.getitems!","text":"getitems!(c::Tuple,a::Tuple,i...) -> Tuple\n\nExtracts the i-th entry of all arrays in the tuple a using the caches in the tuple c. The results is a tuple containing each one of the extracted entries.\n\nExample\n\nIterating over three different arrays simultaneously using getitems!\n\nusing InplaceArrays.Arrays\n\na = collect(0:5)\nb = collect(10:15)\nc = collect(20:25)\n\ncaches = array_caches(a,b,c)\nfor i in eachindex(a)\n   s = getitems!(caches,(a,b,c),i)\n   println(\"$i -> $s\")\nend\n\n# output\n1 -> (0, 10, 20)\n2 -> (1, 11, 21)\n3 -> (2, 12, 22)\n4 -> (3, 13, 23)\n5 -> (4, 14, 24)\n6 -> (5, 15, 25)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.array_caches","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.array_caches","text":"array_caches(a::AbstractArray...) -> Tuple\n\nReturns a tuple with the cache of each array in a.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.testitems","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.testitems","text":"testitems(b::AbstractArray...) -> Tuple\n\nReturns a tuple with the result of testitem applied to each of the arrays in b.\n\nExamples\n\nusing InplaceArrays.Arrays\n\na = collect(3:10)\nb = Int[]\nc = Float64[]\nd = ones(10)\n\ntestitems(a,b,c,d)\n\n# output\n(3, 0, 0.0, 1.0)\n\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Creting-lazy-operation-trees-1","page":"Gridap.Arrays","title":"Creting lazy operation trees","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"apply(f,a::AbstractArray...)\napply(::Type{T},f,a::AbstractArray...) where T\napply(f::AbstractArray,a::AbstractArray...)\napply(::Type{T},f::AbstractArray,a::AbstractArray...) where T\napply_all","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(f,a::AbstractArray...) -> AbstractArray\n\nApplies the kernel f to the entries of the arrays in a (see the definition of Kernel).\n\nThe resulting array r is such that r[i] equals to apply_kernel(f,ai...) where ai is the tuple containing the i-th entry of the arrays in a (see function apply_kernel for more details). In other words, the resulting array is numerically equivalent to:\n\nmap( (x...)->apply_kernel(f,x...), a...)\n\nSee the apply_kernel function for details.\n\nExamples\n\nUsing a function as kernel\n\nusing InplaceArrays.Arrays\n\na = collect(0:5)\nb = collect(10:15)\n\nc = apply(+,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\nUsing a user-defined kernel\n\nusing InplaceArrays.Arrays\nimport InplaceArrays.Arrays: apply_kernel!\n\na = collect(0:5)\nb = collect(10:15)\n\nstruct MySum <: Kernel end\n\napply_kernel!(cache,::MySum,x,y) = x + y\n\nk = MySum()\n\nc = apply(k,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},Any,Vararg{AbstractArray,N} where N}} where T","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(::Type{T},f,a::AbstractArray...) where T\n\nLike apply(f,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(f::AbstractArray,a::AbstractArray...) -> AbstractArray\n\nApplies the kernels in the array of kernels f to the entries in the arrays in a.\n\nThe resulting array has the same entries as the one obtained with:\n\nmap( apply_kernel, f, a...)\n\nSee the apply_kernel function for details.\n\nExample\n\n\"Evaluating\" an array of functions\n\nusing InplaceArrays.Arrays\n\nf = [+,-,max,min]\na = [1,2,3,4]\nb = [4,3,2,1]\n\nc = apply(f,a,b)\n\nprintln(c)\n\n# output\n[5, -1, 3, 1]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},AbstractArray,Vararg{AbstractArray,N} where N}} where T","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(::Type{T},f::AbstractArray,a::AbstractArray...) where T\n\nLike apply(f::AbstractArray,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply_all","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_all","text":"apply_all(f::Tuple,a::AbstractArray...) -> Tuple\n\nNumerically equivalent to \n\ntuple( ( apply(fi, a...) for fi in f)... )\n\nExamples\n\nusing InplaceArrays.Arrays\n\na = [1,2,3,4]\nb = [4,3,2,1]\n\nc = apply_all( (+,-), a, b)\n\n# Equivalent to\n# c = ( apply(+,a,b), apply(-,a,b) )\n\nprintln(c)\n\n# output\n([5, 5, 5, 5], [-3, -1, 1, 3])\n\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Operation-kernels-1","page":"Gridap.Arrays","title":"Operation kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Kernel\napply_kernel!(cache,f,x...)\nkernel_cache(f,x...)\nkernel_return_type(f,x...)\ntest_kernel","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.Kernel","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.Kernel","text":"Abstract type representing the operations to be used in the apply function.\n\nDerived types must implement the following method:\n\napply_kernel!(cache,k,x...)\n\nand optionally these ones:\n\nkernel_cache(k,x...)\nkernel_return_type(k,x...)\n\nThe kernel interface can be tested with the test_kernel function.\n\nNote that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from Kernel. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Kernel. For instance, a default implementation is available for Function objects.  However, we recommend that new types inherit from Kernel.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_kernel!","text":"apply_kernel!(cache,f,x...)\n\nApplies the kernel f at the arguments x... using the scratch data provided in the given cache object. The cache object is built with the kernel_cache function using arguments of the same type as in x. In general, the returned value y can share some part of its state with the cache object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various cache objects (e.g., one cache per thread).\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_cache","text":"kernel_cache(f,x...)\n\nReturns the cache needed to apply kernel f with arguments of the same type as the objects in x. This function returns nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_return_type","text":"kernel_return_type(f,x...)\n\nReturns the type of the result of calling kernel f with arguments of the types of the objects x.\n\nIt defaults to typeof(apply_kernel(f,x...))\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.test_kernel","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.test_kernel","text":"test_kernel(f,x::Tuple,y,cmp=(==))\n\nFunction used to test if the kernel f has been implemented correctly. f is a kernel object, x is a tuple containing the arguments  of the kernel, and y is the expected result. Function cmp is used to compare the computed result with the expected one. The checks are done with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Other-functions-using-kernels-1","page":"Gridap.Arrays","title":"Other functions using kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"apply_kernel\napply_kernels!\nkernel_caches\nkernel_return_types","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.apply_kernel","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_kernel","text":"apply_kernel(f,x...)\n\napply the kernel f at the arguments in x by creating a temporary cache internally. This functions is equivalent to\n\ncache = kernel_cache(f,x...)\napply_kernel!(cache,f,x...)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.apply_kernels!","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_kernels!","text":"apply_kernels!(caches::Tuple,fs::Tuple,x...) -> Tuple\n\nApplies the kernels in the tuple fs at the arguments x... by using the corresponding cache objects in the tuple caches. The result is also a tuple containing the result for each kernel in fs.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_caches","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_caches","text":"kernel_caches(fs::Tuple,x...) -> Tuple\n\nReturns a tuple with the cache corresponding to each kernel in fs for the arguments x....\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_return_types","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_return_types","text":"kernel_return_types(f::Tuple,x...) -> Tuple\n\nComputes the return types of the kernels in f when called with arguments x.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Build-in-kernels-1","page":"Gridap.Arrays","title":"Build-in kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"bcast\nelem\ncontract","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.bcast","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.bcast","text":"bcast(f::Function)\n\nReturns a kernel object that represents the \"boradcasted\" version of the given function f.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.elem","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.elem","text":"elem(f::Function)\n\nReturns a kernel that represents the element-wise version of the operation f It does not broadcast in singleton axes. Thus, allows some performance optimizations with respect to broadcast.\n\nwarning: Warning\nnot needed any more, to be deleted\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.contract","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.contract","text":"contract(f::Function)\n\nLike the dot product between to vectors, but using operation f instead of * between components.\n\nwarning: Warning\nnot needed any more, to be deleted\n\nExamples\n\nusing InplaceArrays.Arrays\nk = contract(-)\napply_kernel(k,[1,2],[2,4]) # Equivalent to (1-2) + (2-4)\n# output\n-3\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Concrete-array-implementations-1","page":"Gridap.Arrays","title":"Concrete array implementations","text":"","category":"section"},{"location":"Arrays/#CachedArray-1","page":"Gridap.Arrays","title":"CachedArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CachedArray\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\nsetsize!\nCachedMatrix\nCachedVector","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.CachedArray","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedArray","text":"mutable struct CachedArray{T, N, A<:AbstractArray{T,N}} <: AbstractArray{T,N}\n\nType providing a re-sizable array.\n\nThe size of a CachedArray is changed via the setsize! function.\n\nA CachedArray can be build with the constructors\n\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\n\nusing InplaceArrays.Arrays\n# Create an empty CachedArray\na = CachedArray(Float64,2)\n# Resize to new shape (2,3)\nsetsize!(a,(2,3))\nsize(a)\n# output\n(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedArray","text":"CachedArray(a::AbstractArray)\n\nConstructs a CachedArray from a given array.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedArray","text":"CachedArray(T,N)\n\nConstructs an empty CachedArray of element type T and N dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.setsize!","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.setsize!","text":"setsize!(a, s)\n\n\nChanges the size of the CachedArray a to the size described the the tuple s. After calling setsize!, the array can store uninitialized values.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.CachedMatrix","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedMatrix","text":"const CachedMatrix{T,A} = CachedArray{T,2,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.CachedVector","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedVector","text":"const CachedVector{T,A} = CachedArray{T,1,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#CompressedArray-1","page":"Gridap.Arrays","title":"CompressedArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CompressedArray\nCompressedArray(::AbstractArray,::AbstractArray)","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.CompressedArray","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CompressedArray","text":"struct CompressedArray{T,N,A,P} <: AbstractArray{T,N}\n  values::A\n  ptrs::P\nend\n\nType representing an array with a reduced set of values. The array is represented by a short array of values, namely the field values, and a large array of indices, namely the field ptrs. The i-th component of the resulting array is defined as values[ptrs[i]]. The type parameters A, and P are restricted to be array types by the inner constructor of this struct.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.CompressedArray-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CompressedArray","text":"CompressedArray(values::AbstractArray,ptrs::AbstractArray)\n\nCreates a CompressedArray object by the given arrays of values and  ptrs.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Table-1","page":"Gridap.Arrays","title":"Table","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Table\nTable(data::AbstractVector,ptrs::AbstractVector)","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.Table","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.Table","text":"struct Table{T,D,P} <: AbstractVector{Vector{T}}\n  data::D\n  ptrs::P\nend\n\nType representing a list of lists (i.e., a table) in  compressed format.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.Table-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.Table","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#LocalToGlobalArray-1","page":"Gridap.Arrays","title":"LocalToGlobalArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"LocalToGlobalArray\nLocalToGlobalArray(::AbstractArray{<:AbstractArray},::AbstractArray)","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.LocalToGlobalArray","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.LocalToGlobalArray","text":"\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.LocalToGlobalArray-Tuple{AbstractArray{#s5,N} where N where #s5<:AbstractArray,AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.LocalToGlobalArray","text":"\n\n\n\n","category":"method"},{"location":"Helpers/#","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"CurrentModule = InplaceArrays.Helpers","category":"page"},{"location":"Helpers/#Gridap.Helpers-1","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"","category":"section"},{"location":"Helpers/#","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"Modules = [Helpers,]","category":"page"},{"location":"Helpers/#InplaceArrays.Helpers","page":"Gridap.Helpers","title":"InplaceArrays.Helpers","text":"This module provides a set of helper macros and helper functions\n\nThe exported macros are:\n\n@abstractmethod\n@notimplemented\n@notimplementedif\ntfill\n@unreachable\n\n\n\n\n\n","category":"module"},{"location":"Helpers/#InplaceArrays.Helpers.tfill-Union{Tuple{D}, Tuple{Any,Val{D}}} where D","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.tfill","text":"tfill(v, ::Val{D}) where D\n\nReturns a tuple of length D that contains D times the object v. In contrast to tuple(fill(v,D)...) which returns the same result, this function is type-stable.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#InplaceArrays.Helpers.@abstractmethod-Tuple{}","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@abstractmethod","text":"@abstractmethod\n\nMacro used in generic functions that must be overloaded by derived types.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#InplaceArrays.Helpers.@notimplemented","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@notimplemented","text":"@notimplemented\n@notimplemented \"Error message\"\n\nMacro used to raise an error, when something is not implemented.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#InplaceArrays.Helpers.@notimplementedif","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@notimplementedif","text":"@notimplementedif condition\n@notimplementedif condition \"Error message\"\n\nMacro used to raise an error if the condition is true\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#InplaceArrays.Helpers.@unreachable","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@unreachable","text":"@unreachable\n@unreachable \"Error message\"\n\nMacro used to make sure that a line of code is never reached.\n\n\n\n\n\n","category":"macro"},{"location":"Polynomials/#","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"CurrentModule = InplaceArrays.Polynomials","category":"page"},{"location":"Polynomials/#Gridap.Polynomials-1","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"","category":"section"},{"location":"Polynomials/#","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"Modules = [Polynomials,]","category":"page"},{"location":"Polynomials/#InplaceArrays.Polynomials","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials","text":"This module provides a collection of multivariate polynomial bases.\n\nThe exported names are:\n\nMonomialBasis\nQCurlGradMonomialBasis\nQGradMonomialBasis\nchange_basis\n\n\n\n\n\n","category":"module"},{"location":"Polynomials/#InplaceArrays.Polynomials.MonomialBasis","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.MonomialBasis","text":"struct MonomialBasis{...} <: Field\n\nType representing a basis of multivariate scalar-valued, vector-valued, or tensor-valued, iso- or aniso-tropic monomials. The type parameters and fields of this struct are not public, they are  private implementation details.   This type fully implements the Field interface, with up to second order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#InplaceArrays.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Function}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, order::Int [, filter::Function]) where {D,T}\n\nReturns an instance of MonomialBasis representing a multivariate polynomial basis in D dimensions, of polynomial degree order, whose value is represented by the type T. The type T is typically <:Number, e.g., Float64 for scalar-valued functions and VectorValue{D,Float64} for vector-valued ones.\n\nFilter function\n\nThe filter function is used to select which terms of the tensor product space of order order in D dimensions are to be used. If the filter is not provided, the full tensor-product space is used by default leading to a multivariate polynomial space of type Q. The signature of the filter function is\n\n(e,order) -> Bool\n\nwhere e is a tuple of D integers containing the exponents of a multivariate monomial. The following filters are used to select well known polynomial spaces\n\nQ space: (e,order) -> true\nP space: (e,order) -> sum(e) <= order\n\"Serendipity\" space: (e,order) -> sum( [ i for i in e if i>1 ] ) <= order\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#InplaceArrays.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Tuple{Vararg{Int64,D}}}, Tuple{Type{T},Tuple{Vararg{Int64,D}},Function}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, orders::Tuple [, filter::Function]) where {D,T}\n\nThis version of the constructor allows to pass a tuple orders containing the polynomial order to be used in each of the D dimensions in order to  construct and anisotropic tensor-product space.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#InplaceArrays.Polynomials.QCurlGradMonomialBasis","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QCurlGradMonomialBasis","text":"struct QCurlGradMonomialBasis{...} <: Field\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Raviart-Thomas reference elements on n-cubes. The type parameters and fields of this struct are not public.   This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#InplaceArrays.Polynomials.QCurlGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QCurlGradMonomialBasis","text":"QCurlGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QCurlGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#InplaceArrays.Polynomials.QGradMonomialBasis","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QGradMonomialBasis","text":"struct QGradMonomialBasis{...} <: Field\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Nedelec reference elements on n-cubes. The type parameters and fields of this struct are not public.   This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#InplaceArrays.Polynomials.QGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QGradMonomialBasis","text":"QGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#InplaceArrays.Polynomials.change_basis-Tuple{Any,AbstractArray{T,2} where T}","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.change_basis","text":"change_basis(basis,changeofbasis::AbstractMatrix)\n\nExamples\n\nCompute the Lagrangian basis associated with a set of nodes\n\nusing LinearAlgebra\nusing InplaceArrays.Fields\nusing InplaceArrays.Polynomials\n\nD = 2\norder = 1\nf = MonomialBasis{D}(Float64,order)\n\nnodes = Point{2,Int}[(0,0),(1,0),(0,1),(1,1)]\nchange = inv(evaluate(f,nodes))\n\ng = change_basis(f,change)\nprintln(evaluate(g,nodes))\n\n# output\n[1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]\n\n\n\n\n\n\n","category":"method"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"CurrentModule = InplaceArrays.TensorValues","category":"page"},{"location":"TensorValues/#Gridap.TensorValues-1","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"TensorValues","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues","text":"This module provides concrete implementations of Number that represent 1st, 2nd and general order tensors.\n\nWhy\n\nThe main feature of this module is that the provided types do not extend from AbstractArray, but from Number!\n\nThis allows one to work with them as if they were scalar values in broadcasted operations on arrays of VectorValue objects (also for TensorValue or MultiValue objects). For instance, one can perform the following manipulations:\n\n# Assing a VectorValue to all the entries of an Array of VectorValues\nA = zeros(VectorValue{2,Int}, (4,5))\nv = VectorValue(12,31)\nA .= v # This is posible since  VectorValue <: Number\n\n# Broatcasing of tensor operations in arrays of TensorValues\nt = TensorValue(13,41,53,17) # creates a 2x2 TensorValue\ng = TensorValue(32,41,3,14) # creates another 2x2 TensorValue\nB = fill(t,(1,5))\nC = inner.(g,B) # inner product of g against all TensorValues in the array B\n@show C\n# C = [2494 2494 2494 2494 2494]\n\nThe exported names are:\n\nMultiValue\nTensorValue\nVectorValue\nchange_eltype\ninner\nmeas\nmutable\nn_components\nouter\nsymmetic_part\n\n\n\n\n\n","category":"module"},{"location":"TensorValues/#Exported-types-1","page":"Gridap.TensorValues","title":"Exported types","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"MultiValue\nVectorValue\nTensorValue","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.MultiValue","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.MultiValue","text":"Type representing a multi-dimensional value\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#InplaceArrays.TensorValues.VectorValue","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.VectorValue","text":"Type representing a first-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#InplaceArrays.TensorValues.TensorValue","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.TensorValue","text":"Type representing a second-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Constructors-1","page":"Gridap.TensorValues","title":"Constructors","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"mutable\nchange_eltype","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.mutable","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.mutable","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#InplaceArrays.TensorValues.change_eltype","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.change_eltype","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#Info-getters-1","page":"Gridap.TensorValues","title":"Info getters","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"n_components","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.n_components","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.n_components","text":"n_components(::Type)\n\nReturns the number of components stored in the given type. Implemented for types <:Real and <:MultiValue. Also available for instances of these types.\n\n\n\n\n\n","category":"function"},{"location":"TensorValues/#Operations-1","page":"Gridap.TensorValues","title":"Operations","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"inner\nouter\nmeas\nsymmetic_part","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.inner","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.inner","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#InplaceArrays.TensorValues.outer","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.outer","text":"outer(∇,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\nouter(f,∇)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"TensorValues/#InplaceArrays.TensorValues.meas","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.meas","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#InplaceArrays.TensorValues.symmetic_part","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.symmetic_part","text":"\n\n\n\n","category":"function"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Documentation the Gridap.jl library","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n  \"index.md\",\n  \"Gridap.md\",\n  \"Helpers.md\",\n  \"Inference.md\",\n  \"TensorValues.md\",\n  \"Arrays.md\",\n  \"Fields.md\",\n  \"Polynomials.md\",\n  \"ReferenceFEs.md\",\n  ]","category":"page"}]
}
