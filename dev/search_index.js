var documenterSearchIndex = {"docs":
[{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"DocTestSetup = quote\n    using InplaceArrays\nend","category":"page"},{"location":"Functors/#The-Functor-interface-1","page":"The functor interface","title":"The Functor interface","text":"","category":"section"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"Often, it is needed to implement functions that need some scratch data (e.g., pre-allocating the output). The question is, where to store this data? There are three main answers to this question: 1) store the data in the function object as part of its state, 2) allocate the scratch data each time the operation is performed, and 3) the user allocates and passes the scratch data when needed. Clearly, 1) it is not save if several calls to the operation are using the same scratch data (e.g., multi-threading). 2) is save, but it can be inefficient if the operation is performed at low granularity. 3) is both save and efficient, but requires some extra work by the user.","category":"page"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"In Gridap, we adopt the 3rd option. In order to unify the interfaces of functions using this approach, we introduce the Functor interface. Any type is referred to as a Functor if it implements the following interface. We rely in duck typing here. There is not an abstract type representing a functor.","category":"page"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"InplaceArrays.Functors.evaluate_functor!\nInplaceArrays.Functors.functor_cache","category":"page"},{"location":"Functors/#InplaceArrays.Functors.evaluate_functor!","page":"The functor interface","title":"InplaceArrays.Functors.evaluate_functor!","text":"y = evaluate_functor!(cache,f,x...)\n\nEvaluates the functor f at the arguments x... using the scratch data provided in the given cache object. The cache object is built with the functor_cache function using arguments of the same type as in x... In general, the returned value y can share some part of its state with the cache object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various cache objects (e.g., one cache per thread).\n\n\n\n\n\n","category":"function"},{"location":"Functors/#InplaceArrays.Functors.functor_cache","page":"The functor interface","title":"InplaceArrays.Functors.functor_cache","text":"cache = functor_cache(f,x...)\n\nReturns the cache needed to evaluate functor f with arguments of the same type as the objects in x....\n\n\n\n\n\n","category":"function"},{"location":"Functors/#Default-implementations-1","page":"The functor interface","title":"Default implementations","text":"","category":"section"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"We provide some default (obvious) implementations of this interface so that Function, Number, and AbstractArray objects behave like functors.","category":"page"},{"location":"Functors/#Examples-1","page":"The functor interface","title":"Examples","text":"","category":"section"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"Calling the + function via the functor interface.","category":"page"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"julia> cache = functor_cache(+,0,0)\n\njulia> evaluate_functor!(cache,+,1,2)\n3\n\njulia> evaluate_functor!(cache,+,-1,10)\n9","category":"page"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"Number and AbstractArray objects behave like \"constant\" functors.","category":"page"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"julia> a = 2.0\n2.0\n\njulia> cache = functor_cache(a,0)\n\njulia> evaluate_functor!(cache,a,1)\n2.0\n\njulia> evaluate_functor!(cache,a,2)\n2.0\n\njulia> evaluate_functor!(cache,a,3)\n2.0","category":"page"},{"location":"Functors/#Evaluating-a-functor-without-cache-1","page":"The functor interface","title":"Evaluating a functor without cache","text":"","category":"section"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"InplaceArrays.Functors.evaluate_functor","category":"page"},{"location":"Functors/#InplaceArrays.Functors.evaluate_functor","page":"The functor interface","title":"InplaceArrays.Functors.evaluate_functor","text":"evaluate_functor(f,x...)\n\nEvaluate the fuctor f at the arguments x... by creating a temporary cache internally. This functions is equivalent to\n\ncache = functor_cache(f,x...)\nevaluate_functor!(cache,f,x...)\n\n\n\n\n\n","category":"function"},{"location":"Functors/#Working-with-several-functors-at-once-1","page":"The functor interface","title":"Working with several functors at once","text":"","category":"section"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"evaluate_functors!\nfunctor_caches","category":"page"},{"location":"Functors/#InplaceArrays.Functors.evaluate_functors!","page":"The functor interface","title":"InplaceArrays.Functors.evaluate_functors!","text":"evaluate_functors!(caches::Tuple,fs::Tuple,x...) -> Tuple\n\nEvaluates the functors in the tuple fs at the arguments x... by using the corresponding cache objects in the tuple caches. The result is also a tuple containing the result for each functor in fs.\n\n\n\n\n\n","category":"function"},{"location":"Functors/#InplaceArrays.Functors.functor_caches","page":"The functor interface","title":"InplaceArrays.Functors.functor_caches","text":"functor_caches(fs::Tuple,x...) -> Tuple\n\nReturns a tuple with the cache corresponding to each functor in fs for the arguments x....\n\n\n\n\n\n","category":"function"},{"location":"Functors/#Broadcasting-1","page":"The functor interface","title":"Broadcasting","text":"","category":"section"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"bcast","category":"page"},{"location":"Functors/#InplaceArrays.Functors.bcast","page":"The functor interface","title":"InplaceArrays.Functors.bcast","text":"bcast(f::Function)\n\nReturns a functor object that represents the \"boradcasted\" version of the given function f.\n\nExamples\n\njulia> op = bcast(*)\nInplaceArrays.Functors.BCasted{typeof(*)}(*)\n\njulia> x = ones(2,3)\n2×3 Array{Float64,2}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> y = 2\n2\n\njulia> evaluate_functor(op,x,y)\n2×3 CachedArray{Float64,2,Array{Float64,2}}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\n\n\n\n\n","category":"function"},{"location":"Functors/#Composition-1","page":"The functor interface","title":"Composition","text":"","category":"section"},{"location":"Functors/#","page":"The functor interface","title":"The functor interface","text":"compose_functors","category":"page"},{"location":"Functors/#InplaceArrays.Functors.compose_functors","page":"The functor interface","title":"InplaceArrays.Functors.compose_functors","text":"c = compose_functors(g,fs...)\n\nReturns an object c representing the \"composition\" of functor g with several functors fs. The resulting object c is such that\n\nevaluate_functor(c,x...)\n\nis equivalent to\n\nfxs = evaluate_functors(fs,x...)\nevaluate_functor(g,fxs...)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Extended-AbstractArray-interface-1","page":"Extended AbstractArray interface","title":"Extended AbstractArray interface","text":"","category":"section"},{"location":"Arrays/#","page":"Extended AbstractArray interface","title":"Extended AbstractArray interface","text":"When implementing new array types, we encounter a similar problem than when implementing some functions: It can be needed some scratch data (e.g., allocating the output), when recovering an item from an array (typically if the array elements are mutable or non-isbits objects, e.g., for \"lazy\" array of arrays). Here, we adopt the same solution as for functors: the user provides the scratch data. However, the Julia array interface does not support this approach. When calling a[i], in order to get the element with index i in array a, there is no extra argument for the scratch data. In order to circumvent this problem, we add new methods to the AbstractArray interface of Julia. We provide default implementations to the new methods, so that any AbstractArray can be used with the extended interface. The most important among the new methods is getindex!, which allows to recover an item in the array by passing some scratch data. The new mehtods are listed below.","category":"page"},{"location":"Arrays/#","page":"Extended AbstractArray interface","title":"Extended AbstractArray interface","text":"getindex!\narray_cache\nuses_hash\ntestitem\ntestvalue","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.getindex!","page":"Extended AbstractArray interface","title":"InplaceArrays.Arrays.getindex!","text":"getindex!(cache,a::AbstractArray,i...)\n\nReturns the item of the array a associated with index i by (possibly) using the scratch data passed in the cache object.\n\nIt defaults to\n\ngetindex!(cache,a::AbstractArray,i...) = a[i...]\n\nThe cache object is constructed with the array_cache function.\n\nExamples\n\njulia> a = collect(1:4)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> cache = array_cache(a)\n\njulia> getindex!(cache,a,2)\n2\n\njulia> getindex!(cache,a,4)\n4\n\nIn this example, using the extended interface provides little benefit, but for new array types that need scratch data, efficient implementations of getindex! can make a performance difference by avoiding  low granularity allocations.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.array_cache","page":"Extended AbstractArray interface","title":"InplaceArrays.Arrays.array_cache","text":"array_cache(a::AbstractArray)\n\nReturns a cache object to be used in the getindex! function. It defaults to \n\narray_cache(a::T) where T = nothing\n\nfor types T such that uses_hash(T) == Val(false), and \n\nfunction array_cache(a::T) where T\n  hash = Dict{UInt,Any}()\n  array_cache(hash,a)\nend\n\nfor types T such that uses_hash(T) == Val(true), see the uses_hash function. In the later case, the type T should implement the following signature:\n\narray_cache(hash::Dict,a::AbstractArray)\n\nwhere we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object a has already build a cache and re-use it as follows\n\nid = objectid(a)\nif haskey(hash,id)\n  cache = hash[id] # Reuse cache\nelse\n  cache = ... # Build a new cache depending on your needs\n  hash[id] = cache # Register the cache in the hash table\nend\n\nIn multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.uses_hash","page":"Extended AbstractArray interface","title":"InplaceArrays.Arrays.uses_hash","text":"uses_hash(::Type{T}) where T <:AbstractArray\n\nThis function is used to specify if the type T uses the hash-based mechanism to reuse caches.  It should return either Val(true) or Val(false). It defaults to\n\nuses_hash(::Type{<:AbstractArray}) = Val(false)\n\nOnce this function is defined for the type T it can also be called on instances of T.\n\nExamples\n\njulia> uses_hash(Matrix{Float64})\nVal{false}()\n\njulia> a = ones(2,3)\n2×3 Array{Float64,2}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> uses_hash(a)\nVal{false}()\n\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.testitem","page":"Extended AbstractArray interface","title":"InplaceArrays.Arrays.testitem","text":"testitem(a::AbstractArray)\n\nReturns an arbitrary instance of eltype(a). The default returned value is the first entry in the array if length(a)>0 and testvalue(eltype(a)) if length(a)==0 See the testvalue function.\n\nThis function is useful to determine the type resulting from applying a given function to the items in the array without calling the Base._return_type function.\n\nExamples\n\njulia> a = collect(1:0)\n0-element Array{Int64,1}\n\njulia> ai = testitem(a) # Safely works with empty arrays\n0\n\njulia> typeof(sqrt(ai))\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.testvalue","page":"Extended AbstractArray interface","title":"InplaceArrays.Arrays.testvalue","text":"testvalue(::Type{T}) where T\n\nReturns an arbitrary instance of type T. It defaults to zero(T) for non-array types and to an empty array for array types.  This function is useful to determine the type returned by a function without calling Base._return_type.\n\nExamples\n\njulia> a = testvalue(Int)\n0\n\njulia> b = testvalue(Float64)\n0.0\n\njulia> typeof(a + b)\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Documentation for InplaceArrays.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"Functors.md\", \"Arrays.md\"]","category":"page"}]
}
