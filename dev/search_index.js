var documenterSearchIndex = {"docs":
[{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"CurrentModule = InplaceArrays.Fields","category":"page"},{"location":"Fields/#Gridap.Fields-1","page":"Gridap.Fields","title":"Gridap.Fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"Fields","category":"page"},{"location":"Fields/#InplaceArrays.Fields","page":"Gridap.Fields","title":"InplaceArrays.Fields","text":"This module provides:\n\nAn interface for physical fields, basis of physical fields and related objects.\nHelpers functions to work with fields and arrays of fields.\nHelpers functions to create lazy operation trees from fields and arrays of fields\n\nThe exported names are:\n\nField\nPoint\napply_kernel_to_field\napply_to_field_array\nattachmap\ncompose\ncurl\ndivergence\nevaluate\nevaluate!\nevaluate_field\nevaluate_field!\nevaluate_field_array\nevaluate_fields\nevaluate_fields!\nfield_array_cache\nfield_array_gradient\nfield_cache\nfield_caches\nfield_gradient\nfield_gradients\nfield_return_type\nfield_return_types\ngrad2curl\ngradient\ngradient_type\nintegrate\nlaplacian\nlincomb\ntest_array_of_fields\ntest_field\nvarinner\nΔ\nε\n∇\n\n\n\n\n\n","category":"module"},{"location":"Fields/#Interface-1","page":"Gridap.Fields","title":"Interface","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"Field\nPoint\nevaluate_field!(cache,f,x)\nfield_cache(f,x)\nfield_gradient(f)\nfield_return_type(f,x)\nevaluate_gradient!(cache,f,x)\ngradient_cache(f,x)\nevaluate_hessian!(cache,f,x)\nhessian_cache(f,x)\ntest_field","category":"page"},{"location":"Fields/#InplaceArrays.Fields.Field","page":"Gridap.Fields","title":"InplaceArrays.Fields.Field","text":"abstract type Field <: Kernel\n\nAbstract type representing physical fields, bases of fields, and other related objects.  These different cases are distinguished by the return value obtained when evaluating them. E.g., a physical field returns a vector of values when evaluated at a vector of points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThe following functions need to be overloaded:\n\nevaluate_field!(cache,f,x)\nfield_cache(f,x)\n\nThe following functions can be also provided optionally\n\nfield_gradient(f)\nfield_return_type(f,x)\n\nMoreover, if the field_gradient(f) is not provided, a default implementation that uses the following functions will be used.\n\nevaluate_gradient!(cache,f,x)\ngradient_cache(f,x)\n\nIn order to be able to call field_gradient again on the resulting object the following methods have to be provided\n\nevaluate_hessian!(cache,f,x)\nhessian_cache(f,x)\n\nThese four methods are only designed to be called by the default implementation of field_gradient(f) and thus cannot be assumed that they are available for an arbitrary field. For this reason, these functions are not exported. The general way of evaluating a gradient of a field is to build the gradient with field_gradient(f) and evaluating the resulting object. For evaluating the hessian, use two times field_gradient.\n\nThe interface can be tested with\n\ntest_field\n\nMost of the functionality implemented in terms of this interface relies in duck typing (this is why all functions in the interface have the word \"field\").  Thus, it is not strictly needed to work with types that inherit from Field. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Field. For instance, a default implementation is available for numbers, which behave like \"constant\" fields, or arrays of numbers, which behave like \"constant\" bases of fields.  However, we recommend that new types inherit from Field.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#InplaceArrays.Fields.Point","page":"Gridap.Fields","title":"InplaceArrays.Fields.Point","text":"const Point{D,T} = VectorValue{D,T}\n\nType representing a point of D dimensions with coordinates of type T. Fields are evaluated at vectors of Point objects.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field!","text":"evaluate_field!(cache, f, x)\n\n\nReturns an array containing the values of evaluating the field f at the vector of points x by (possibly) using the scratch data in the cache object.  The returned value is  an array,  for which the length of the first axis is length(x), i.e., the number of points where the field has been evaluated.E.g., a physical field returns a vector of np values when evaluated at a vector of np points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThis choice is made\n\nfor performance reasons when integrating fields (i.e., adding contributions at different points) since the added values are closer in memory with this layout.\nIn order to simplify operations between field objects. E.g., the result of evaluating a physical field and a basis of nffields at a vector of np points (which leads to a vector and a matrix of size (np,) and (np,nf) respectively)  can be conveniently added with the broadcasted sum .+ operator.\n\nThe cache object is computed with the field_cache function.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_cache","text":"field_cache(f, x)\n\n\nReturns the cache object needed to evaluate field f at the vector of points x.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_gradient-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_gradient","text":"field_gradient(f)\n\n\nReturns another field that represents the gradient of the given one\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_return_type-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_return_type","text":"field_return_type(f, x)\n\n\nComputes the type obtained when evaluating field f at point x. It returns typeof(evaluate_field(f,x)) by default.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_gradient!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_gradient!","text":"evaluate_gradient!(cache, f, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient_cache","text":"gradient_cache(cache, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_hessian!-Tuple{Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_hessian!","text":"evaluate_hessian!(cache, f, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.hessian_cache-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.hessian_cache","text":"hessian_cache(cache, x)\n\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.test_field","page":"Gridap.Fields","title":"InplaceArrays.Fields.test_field","text":"test_field(\n  f,\n  x::AbstractVector{<:Point},\n  v::AbstractArray,cmp=(==);\n  grad=nothing,\n  hessian=nothing)\n\nFunction used to test the field interface. v is an array containing the expected result of evaluating the field f at the vector of points x. The comparison is performed using  the cmp function. For fields objects that support the field_gradient function, the key-word argument grad can be used. It should contain the result of evaluating field_gradient(f) at x. Idem for hessian. The checks are performed with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Helper-functions-using-fields-1","page":"Gridap.Fields","title":"Helper functions using fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field(f,x)\nevaluate(f::Field,x)\nevaluate!(cache,f::Field,x)\ngradient(f::Field)\n∇\ngradient_type","category":"page"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field","text":"evaluate_field(f, x)\n\n\nEvaluates the field f at the vector of points x by creating a temporary cache internally. Equivalent to \n\nc = field_cache(f,x)\nevaluate_field!(c,f,x)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate-Tuple{InplaceArrays.Fields.Field,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate","text":"evaluate(f::Field,x)\n\nEquivalent to \n\nevaluate_field(f,x)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use evaluate_field instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate!-Tuple{Any,InplaceArrays.Fields.Field,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate!","text":"evaluate!(cache,f::Field,x)\n\nEquivalent to \n\nevaluate_field!(cache,f,x)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use evaluate_field! instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient-Tuple{InplaceArrays.Fields.Field}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient","text":"gradient(f::Field)\n\nEquivalent to\n\nfield_gradient(f)\n\nBut only for types that inherit from Field. Types that implement the field interface but not inherit from Field (e.g., numbers and arrays of numbers) cannot use this function. Use field_gradient instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.∇","page":"Gridap.Fields","title":"InplaceArrays.Fields.∇","text":"const ∇ = gradient\n\nAlias for the gradient function.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#InplaceArrays.Fields.gradient_type","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient_type","text":"gradient_type(::Type{T},x::Point) where T\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Working-with-several-fields-at-once-1","page":"Gridap.Fields","title":"Working with several fields at once","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"field_return_types(f::Tuple,x)\nfield_caches(f::Tuple,x)\nevaluate_fields(f::Tuple,x)\nevaluate_fields!(cf::Tuple,f::Tuple,x)\nfield_gradients(a,b...)\ngradient_all(a,b...)\nevaluate_all(f::Tuple,x)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.field_return_types-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_return_types","text":"field_return_types(f::Tuple,x) -> Tuple\n\nComputes a tuple with the return types of the fields in the tuple f when evaluated at the vector of points x\n\nEquivalent to\n\ntuple(( field_return_type(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_caches-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_caches","text":"field_caches(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((field_cache(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_fields-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_fields","text":"evaluate_fields(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_fields(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_fields!-Tuple{Tuple,Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_fields!","text":"evaluate_fields!(cf::Tuple,f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_fields!(ci,fi,x) for (ci,fi) in zip(c,f))...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_gradients-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_gradients","text":"field_gradients(b...) -> Tuple\n\nEquivalent to\n\nmap(field_gradient,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient_all-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient_all","text":"gradient_all(b...) -> Tuple\n\nEquivalent to\n\nmap(gradient,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate_all-Tuple{Tuple,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_all","text":"evaluate_all(f::Tuple,x) -> Tuple\n\nEquivalent to\n\ntuple((evaluate(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Applying-kernels-to-fields-1","page":"Gridap.Fields","title":"Applying kernels to fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"apply_kernel_to_field(k,f...)\napply_kernel_gradient(k,f...)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.apply_kernel_to_field-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_kernel_to_field","text":"apply_kernel_to_field(k,f...) -> Field\n\nReturns a field obtained by applying the kernel k to the  values of the fields in f. That is, the returned field evaluated at a vector of points x provides the value obtained by applying kernel k to the values of the fields f at the vector of points x. Formally, the resulting field at a  vector of points  x is defined as\n\nfx = evaluate_fields(f,x)\napply_kernel(k,fx...)\n\nIn order to be able to call the field_gradient function of the resulting field, one needs to define the gradient operator associated with the underlying kernel. This is done by adding a new method to apply_kernel_gradient(k,f...) for each kernel type.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.apply_kernel_gradient-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_kernel_gradient","text":"apply_kernel_gradient(k,f...)\n\nReturns a field representing the gradient of the field obtained with\n\napply_kernel_to_field(k,f...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Working-with-arrays-of-fields-1","page":"Gridap.Fields","title":"Working with arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field_array(a::AbstractArray,x::AbstractArray)\nevaluate(::AbstractArray{<:Field},::AbstractArray)\nfield_array_gradient(a::AbstractArray)\ngradient(::AbstractArray{<:Field})\nfield_array_cache(a::AbstractArray,x::AbstractArray)\ntest_array_of_fields","category":"page"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field_array-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field_array","text":"evaluate_field_array(f::AbstractArray,x::AbstractArray) -> AbstractArray\n\nEvaluates the fields in the array f at all the vector of points in the  array of vector of points x and returns the result as a lazy array.\n\nThe result is numerically equivalent to \n\nmap(evaluate_field,a,x)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.evaluate-Tuple{AbstractArray{#s3,N} where N where #s3<:InplaceArrays.Fields.Field,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate","text":"evaluate(a::AbstractArray{<:Field},x::AbstractArray)\n\nEquivalent to \n\nevaluate_field_array(a,x)\n\nBut only for arrays a whose element type inherits from Field. If this is not the case, use evaluate_field_array(a,x) instead.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_array_gradient-Tuple{AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_array_gradient","text":"field_array_gradient(a::AbstractArray)\n\nReturns an array containing the gradients of the fields in the array a. Numerically equivalent to \n\nmap(field_gradient,a)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.gradient-Tuple{AbstractArray{#s3,N} where N where #s3<:InplaceArrays.Fields.Field}","page":"Gridap.Fields","title":"InplaceArrays.Fields.gradient","text":"gradient(f::AbstractArray{<:Field})\n\nEquivalent to \n\nfield_array_gradient(f)\n\nbut only for arrays whose element type is <:Field. Use function field_array_gradient otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_array_cache-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_array_cache","text":"field_array_cache(a::AbstractArray,x::AbstractArray) -> Tuple\n\nReturns the caches needed to perform the following iteration\n\nca, cfi, cx = field_array_cache(a,x)\n\nfor i in length(a)\n  fi = getindex!(ca,a,i)\n  xi = getindex!(cx,x,i)\n  fxi = evaluate!(cfi,fi,xi)\nend\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.test_array_of_fields","page":"Gridap.Fields","title":"InplaceArrays.Fields.test_array_of_fields","text":"function test_array_of_fields(\n  a::AbstractArray,\n  x::AbstractArray,\n  v::AbstractArray,\n  cmp::Function=(==);\n  grad = nothing)\n\nFunction to test an array of fields a. The array v is the expected result when calling  evaluate_field_array(a,x). The entries in the computed array and the expected one are compared with the cmp function. The key-word argument grad is optional. If present, it should contain the expected result of\n\n∇a = field_array_gradient(a)\nevaluate_field_array(∇a,x)\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Working-with-several-arrays-of-fields-at-once-1","page":"Gridap.Fields","title":"Working with several arrays of fields at once","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"evaluate_field_arrays(f::Tuple,x::AbstractArray)\nfield_array_gradients(f...)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.evaluate_field_arrays-Tuple{Tuple,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.evaluate_field_arrays","text":"evaluate_field_arrays(f::Tuple,x::AbstractArray) -> Tuple\n\nEquivalent to\n\ntuple((evaluate_field_array(fi,x) for fi in f)...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.field_array_gradients-Tuple","page":"Gridap.Fields","title":"InplaceArrays.Fields.field_array_gradients","text":"field_array_gradients(f...)\n\nEquivalent to \n\nmap(field_array_gradient,f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Applying-kernels-to-arrays-of-fields-1","page":"Gridap.Fields","title":"Applying kernels to arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"apply_to_field_array(k,f::AbstractArray...)\nkernel_evaluate(k,x,f...)\napply_gradient(k,f...)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.apply_to_field_array-Tuple{Any,Vararg{AbstractArray,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_to_field_array","text":"apply_to_field_array(k,f::AbstractArray...)\n\nReturns an array of fields numerically equivalent to\n\nmap( (x...) -> apply_kernel_to_field(k,x...), f )\n\nThe evaluation and the computation of the gradient of the resulting arrays can be optimized for particular kernels by adding new methods to the kernel_evaluate and  apply_gradient functions respectively.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.kernel_evaluate-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.kernel_evaluate","text":"kernel_evaluate(k,x,f...)\n\nThis function returns by default the array obtained with\n\ng = apply_to_field_array(k,f...)\nevaluate_field_array(g,x)\n\nHowever, it can be rewritten for specific kernels in order to improve performance and simplify the underlying operation tree associated in the returned object.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.apply_gradient-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.apply_gradient","text":"apply_gradient(k,f...)\n\nBy default, it returns the array obtained as\n\na = apply(k,f...)\nfield_array_gradient(a)\n\nHowever, it can be rewritten for specific kernels in order to improve performance and simplify the underlying operation tree associated in the returned object.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Operations-on-fields-and-arrays-of-fields-1","page":"Gridap.Fields","title":"Operations on fields and arrays of fields","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"compose(g::Function,f...)\ncompose(g::Function,f::AbstractArray...)\nlincomb(a::Field,b::AbstractVector)\nlincomb(a::AbstractArray,b::AbstractArray)\nvarinner(a,b)\nvarinner(a::AbstractArray,b::AbstractArray)\nattachmap(f,phi)\nattachmap(f::AbstractArray,phi::AbstractArray)\nintegrate(f,x,w,j)\nintegrate(f::AbstractArray,x,w,j)","category":"page"},{"location":"Fields/#InplaceArrays.Fields.compose-Tuple{Function,Vararg{Any,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.compose","text":"compose(g::Function,f...)\n\nReturns a new field obtained by composition of function g and the fields f. The value of the resulting field at a vector of points x is numerically equivalent to\n\nfx = evaluate_fields(f,x)\napply_kernel(bcast(g), fx...)\n\nThe gradient of the resulting field evaluated at a vector of points x is equivalent to\n\nfx = evaluate_fields(f,x)\napply_kernel(bcast(gradient(g)), fx...)\n\nNote that it is needed to overload gradient(::typeof(g)) for the given function g in order to be able to compute the gradient.\n\nAs in function apply_kernel_to_field if any of the inputs in f is a number or an array instead of a field it will be treated as a \"constant field\".\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.compose-Tuple{Function,Vararg{AbstractArray,N} where N}","page":"Gridap.Fields","title":"InplaceArrays.Fields.compose","text":"compose(g::Function,f::AbstractArray...)\n\nReturns an array of fields numerically equivalent to\n\nmap( (x...)->compose(g,x...), f...)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.lincomb-Tuple{InplaceArrays.Fields.Field,AbstractArray{T,1} where T}","page":"Gridap.Fields","title":"InplaceArrays.Fields.lincomb","text":"lincomb(a::Field,b::AbstractVector)\n\nReturns a field obtained by the \"linear combination\" of the value of the field basis a and the coefficient vector b.  The value of the resulting field evaluated at a vector of points x is defined as\n\nax = evaluate(a,x)\nax*b\n\nOn the other hand, the gradient of the resulting field is defined as\n\n∇ax = evaluate(gradient(a),x)\n∇ax*b\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.lincomb-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.lincomb","text":"lincomb(a::AbstractArray{<:Field},b::AbstractArray)\n\nReturns an array of fields numerically equivalent to\n\nmap(lincomb,a,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.varinner-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.varinner","text":"varinner(a,b)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.varinner-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.varinner","text":"varinner(a::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.attachmap-Tuple{Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.attachmap","text":"attachmap(f,phi)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.attachmap-Tuple{AbstractArray,AbstractArray}","page":"Gridap.Fields","title":"InplaceArrays.Fields.attachmap","text":"attachmap(f::AbstractArray,phi::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.integrate-NTuple{4,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.integrate","text":"integrate(f,x,w,j)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.integrate-Tuple{AbstractArray,Any,Any,Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.integrate","text":"integrate(f::AbstractArray,x,w,j)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Differential-operators-1","page":"Gridap.Fields","title":"Differential operators","text":"","category":"section"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"In addition to the gradient function already discussed, the following differential operators are defined.","category":"page"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"divergence(f)\nsymmetric_gradient(f)\nε\ncurl(f)\ngrad2curl(f)\nlaplacian(f)\nΔ","category":"page"},{"location":"Fields/#InplaceArrays.Fields.divergence-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.divergence","text":"divergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.symmetric_gradient-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.symmetric_gradient","text":"symmetric_gradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.ε","page":"Gridap.Fields","title":"InplaceArrays.Fields.ε","text":"const ε = symmetric_gradient\n\nAlias for the symmetric gradient\n\n\n\n\n\n","category":"function"},{"location":"Fields/#InplaceArrays.Fields.curl-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.curl","text":"curl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.grad2curl-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.grad2curl","text":"grad2curl(∇f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.laplacian-Tuple{Any}","page":"Gridap.Fields","title":"InplaceArrays.Fields.laplacian","text":"laplacian(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.Fields.Δ","page":"Gridap.Fields","title":"InplaceArrays.Fields.Δ","text":"const Δ = laplacian\n\nAlias for the laplacian function\n\n\n\n\n\n","category":"function"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"A fancy way of typing the differential operators is via the nabla object defined in the library.","category":"page"},{"location":"Fields/#","page":"Gridap.Fields","title":"Gridap.Fields","text":"(*)(::typeof(∇),f)\nouter(::typeof(∇),f)\nouter(f,::typeof(∇))\ncross(::typeof(∇),f)","category":"page"},{"location":"Fields/#Base.:*-Tuple{typeof(InplaceArrays.Fields.gradient),Any}","page":"Gridap.Fields","title":"Base.:*","text":"∇*f\n\nEquivalent to\n\ndivergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.TensorValues.outer-Tuple{typeof(InplaceArrays.Fields.gradient),Any}","page":"Gridap.Fields","title":"InplaceArrays.TensorValues.outer","text":"outer(∇,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#InplaceArrays.TensorValues.outer-Tuple{Any,typeof(InplaceArrays.Fields.gradient)}","page":"Gridap.Fields","title":"InplaceArrays.TensorValues.outer","text":"outer(f,∇)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n","category":"method"},{"location":"Fields/#LinearAlgebra.cross-Tuple{typeof(InplaceArrays.Fields.gradient),Any}","page":"Gridap.Fields","title":"LinearAlgebra.cross","text":"cross(∇,f)\n\nEquivalent to\n\ncurl(f)\n\n\n\n\n\n","category":"method"},{"location":"Inference/#","page":"Gridap.Inference","title":"Gridap.Inference","text":"CurrentModule = InplaceArrays.Inference","category":"page"},{"location":"Inference/#Gridap.Inference-1","page":"Gridap.Inference","title":"Gridap.Inference","text":"","category":"section"},{"location":"Inference/#","page":"Gridap.Inference","title":"Gridap.Inference","text":"Inference\nreturn_type(f::Function,::Any...)\nreturn_type_broadcast\ntestargs\ntestargs_broadcast\ntestvalue\ntestvalues","category":"page"},{"location":"Inference/#InplaceArrays.Inference","page":"Gridap.Inference","title":"InplaceArrays.Inference","text":"This module provides a set of helper function to safely infer return types of functions.\n\nIn Gridap, we rely as less as possible in type inference. But, when needed, we adopt the following mechanism in order to compute returned types. We do not rely on the Base._return_type function.\n\nThis module exports following functions:\n\nreturn_type\nreturn_type_broadcast\ntestargs\ntestargs_broadcast\ntestvalue\ntestvalues\n\n\n\n\n\n","category":"module"},{"location":"Inference/#InplaceArrays.Inference.return_type-Tuple{Function,Vararg{Any,N} where N}","page":"Gridap.Inference","title":"InplaceArrays.Inference.return_type","text":"return_type(f::Function, Ts::Vararg{Any,N} where N) -> DataType\n\n\nReturns the type returned by function f when called with arguments of the types in Ts.\n\nThe underlying implementation uses the function testargs to generate some test values in order to call the function and determine the returned type. This mechanism does not use Base._return_type. One of the advantages is that the given function f is called, and thus, meaningful error messages will be displayed if there is any error in f. \n\n\n\n\n\n","category":"method"},{"location":"Inference/#InplaceArrays.Inference.return_type_broadcast","page":"Gridap.Inference","title":"InplaceArrays.Inference.return_type_broadcast","text":"return_type_broadcast(f::Function,Ts::DataType...) -> DataType\n\nLike return_type, but when function f is used in a broadcast operation.\n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testargs","page":"Gridap.Inference","title":"InplaceArrays.Inference.testargs","text":"testargs(f::Function,Ts::DataType...) -> Tuple\n\nReturns a tuple with valid arguments of the types in Ts in order to call function f. It defaults to testvalues(Ts...), see the testvalues function. The user can overload the testargs function for particular functions if the default test arguments are not in the domain of the function and a DomainError is raised.\n\nExamples\n\nFor the following function, the default test argument (which is a zero) is not in the domain. We can overload the testargs function to provide a valid test argument.\n\nusing InplaceArrays.Inference\nimport InplaceArrays.Inference: testargs\nfoo(x) = sqrt(x-1)\ntestargs(::typeof(foo),T::DataType) = (one(T),)\nreturn_type(foo, Int)\n# output\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testargs_broadcast","page":"Gridap.Inference","title":"InplaceArrays.Inference.testargs_broadcast","text":"testargs_broadcast(f, Ts)\n\n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testvalue","page":"Gridap.Inference","title":"InplaceArrays.Inference.testvalue","text":"testvalue(::Type{T}) where T\n\nReturns an arbitrary instance of type T. It defaults to zero(T) for non-array types and to an empty array for array types. This function is used to compute the default test arguments in testargs. It can be overloaded for new types T if zero(T) does not makes sense. \n\n\n\n\n\n","category":"function"},{"location":"Inference/#InplaceArrays.Inference.testvalues","page":"Gridap.Inference","title":"InplaceArrays.Inference.testvalues","text":"testvalues(Ts::DataType...) -> Tuple\n\nReturns a tuple with test values for each of the types in Ts. Equivalent to map(testvalue,Ts).\n\n\n\n\n\n","category":"function"},{"location":"Gridap/#Gridap-1","page":"Gridap","title":"Gridap","text":"","category":"section"},{"location":"Gridap/#","page":"Gridap","title":"Gridap","text":"InplaceArrays","category":"page"},{"location":"Gridap/#InplaceArrays","page":"Gridap","title":"InplaceArrays","text":"Gridap, grid-based approximation of PDEs in the Julia programming language\n\nThis module provides rich set of tools for the numerical solution of PDE, mainly based on finite element methods.\n\nThe module is structured in the following sub-modules:\n\nInplaceArrays.Helpers\nInplaceArrays.Inference\nInplaceArrays.TensorValues\nInplaceArrays.Arrays\nInplaceArrays.Fields\nInplaceArrays.Polynomials\n\nThe exported names are:\n\napply\narray_cache\nbcast\ngetindex!\n\n\n\n\n\n","category":"module"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CurrentModule = InplaceArrays.Arrays","category":"page"},{"location":"Arrays/#Gridap.Arrays-1","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Arrays","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays","page":"Gridap.Arrays","title":"InplaceArrays.Arrays","text":"This module provides:\n\nAn extension of the AbstractArray interface in order to properly deal with mutable caches.\nA mechanism to generate lazy arrays resulting from operations between arrays.\nA collection of concrete implementations of AbstractArray.\n\nThe exported names in this module are:\n\nCachedArray\nCachedMatrix\nCachedVector\nKernel\napply\napply_all\napply_kernel\napply_kernel!\napply_kernels!\narray_cache\narray_caches\nbcast\ncontract\nelem\ngetindex!\ngetitems!\nkernel_cache\nkernel_caches\nkernel_return_type\nkernel_return_types\nsetsize!\ntest_array\ntest_kernel\ntestitem\ntestitems\nuses_hash\n\n\n\n\n\n","category":"module"},{"location":"Arrays/#Extended-AbstractArray-interface-1","page":"Gridap.Arrays","title":"Extended AbstractArray interface","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"When implementing new array types, it can be needed some scratch data (e.g., allocating the output), when recovering an item from an array (typically if the array elements are non-isbits objects). To circumvent this, the user could provide the scratch data needed when getting an item. However, the Julia array interface does not support this approach. When calling a[i], in order to get the element with index i in array a, there is no extra argument for the scratch data. In order to solve this problem, we add new methods to the AbstractArray interface of Julia. We provide default implementations to the new methods, so that any AbstractArray can be used with the extended interface. New array implementations can overload these default implementations to improve performance. The most important among the new methods is getindex!, which allows to recover an item in the array by passing some scratch data.","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"The new methods are:","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getindex!(cache,a::AbstractArray,i...)\narray_cache(a::AbstractArray)\nuses_hash(::Type{<:AbstractArray})\ntestitem(a::AbstractArray)","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"These methods can be stressed with the following function","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"test_array","category":"page"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getindex!(cache,a::AbstractArray,i...)\narray_cache(a::AbstractArray)\nuses_hash(::Type{<:AbstractArray})\ntestitem(a::AbstractArray)\ntest_array","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.getindex!-Tuple{Any,AbstractArray,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.getindex!","text":"getindex!(cache,a::AbstractArray,i...)\n\nReturns the item of the array a associated with index i by (possibly) using the scratch data passed in the cache object.\n\nIt defaults to\n\ngetindex!(cache,a::AbstractArray,i...) = a[i...]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.array_cache-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.array_cache","text":"array_cache(a::AbstractArray)\n\nReturns a cache object to be used in the getindex! function. It defaults to \n\narray_cache(a::T) where T = nothing\n\nfor types T such that uses_hash(T) == Val(false), and \n\nfunction array_cache(a::T) where T\n  hash = Dict{UInt,Any}()\n  array_cache(hash,a)\nend\n\nfor types T such that uses_hash(T) == Val(true), see the uses_hash function. In the later case, the type T should implement the following signature:\n\narray_cache(hash::Dict,a::AbstractArray)\n\nwhere we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object a has already build a cache and re-use it as follows\n\nid = objectid(a)\nif haskey(hash,id)\n  cache = hash[id] # Reuse cache\nelse\n  cache = ... # Build a new cache depending on your needs\n  hash[id] = cache # Register the cache in the hash table\nend\n\nThis mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.uses_hash-Tuple{Type{#s3} where #s3<:AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.uses_hash","text":"uses_hash(::Type{<:AbstractArray})\n\nThis function is used to specify if the type T uses the hash-based mechanism to reuse caches.  It should return either Val(true) or Val(false). It defaults to\n\nuses_hash(::Type{<:AbstractArray}) = Val(false)\n\nOnce this function is defined for the type T it can also be called on instances of T.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.testitem-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.testitem","text":"testitem(a::AbstractArray{T,N} where N) -> Any\n\n\nReturns an arbitrary instance of eltype(a). The default returned value is the first entry in the array if length(a)>0 and testvalue(eltype(a)) if length(a)==0 See the testvalue function.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.test_array","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.test_array","text":"test_array(\n  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}\n\nChecks if the entries in a and b are equal using the comparison function cmp. It also stresses the new methods added to the AbstractArray interface interface.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Working-with-several-arrays-at-once-1","page":"Gridap.Arrays","title":"Working with several arrays at once","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"getitems!\narray_caches\ntestitems","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.getitems!","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.getitems!","text":"getitems!(c::Tuple,a::Tuple,i...) -> Tuple\n\nExtracts the i-th entry of all arrays in the tuple a using the caches in the tuple c. The results is a tuple containing each one of the extracted entries.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.array_caches","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.array_caches","text":"array_caches(a::AbstractArray...) -> Tuple\n\nReturns a tuple with the cache of each array in a.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.testitems","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.testitems","text":"testitems(b::AbstractArray...) -> Tuple\n\nReturns a tuple with the result of testitem applied to each of the arrays in b.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Creting-lazy-operation-trees-1","page":"Gridap.Arrays","title":"Creting lazy operation trees","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"apply(f,a::AbstractArray...)\napply(::Type{T},f,a::AbstractArray...) where T\napply(f::AbstractArray,a::AbstractArray...)\napply(::Type{T},f::AbstractArray,a::AbstractArray...) where T\napply_all","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Tuple{Any,Vararg{AbstractArray,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(f,a::AbstractArray...) -> AbstractArray\n\nApplies the kernel f to the entries of the arrays in a (see the definition of Kernel).\n\nThe resulting array r is such that r[i] equals to apply_kernel(f,ai...) where ai is the tuple containing the i-th entry of the arrays in a (see function apply_kernel for more details). In other words, the resulting array is numerically equivalent to:\n\nmap( (x...)->apply_kernel(f,x...), a...)\n\nSee the apply_kernel function for details.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},Any,Vararg{AbstractArray,N} where N}} where T","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(::Type{T},f,a::AbstractArray...) where T\n\nLike apply(f,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Tuple{AbstractArray,Vararg{AbstractArray,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(f::AbstractArray,a::AbstractArray...) -> AbstractArray\n\nApplies the kernels in the array of kernels f to the entries in the arrays in a.\n\nThe resulting array has the same entries as the one obtained with:\n\nmap( apply_kernel, f, a...)\n\nSee the apply_kernel function for details.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply-Union{Tuple{T}, Tuple{Type{T},AbstractArray,Vararg{AbstractArray,N} where N}} where T","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply","text":"apply(::Type{T},f::AbstractArray,a::AbstractArray...) where T\n\nLike apply(f::AbstractArray,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.apply_all","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_all","text":"apply_all(f::Tuple,a::AbstractArray...) -> Tuple\n\nNumerically equivalent to \n\ntuple( ( apply(fi, a...) for fi in f)... )\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Operation-kernels-1","page":"Gridap.Arrays","title":"Operation kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Kernel\napply_kernel!(cache,f,x...)\nkernel_cache(f,x...)\nkernel_return_type(f,x...)\ntest_kernel","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.Kernel","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.Kernel","text":"Abstract type representing the operations to be used in the apply function.\n\nDerived types must implement the following method:\n\napply_kernel!(cache,k,x...)\n\nand optionally these ones:\n\nkernel_cache(k,x...)\nkernel_return_type(k,x...)\n\nThe kernel interface can be tested with the test_kernel function.\n\nNote that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from Kernel. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Kernel. For instance, a default implementation is available for Function objects.  However, we recommend that new types inherit from Kernel.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.apply_kernel!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_kernel!","text":"apply_kernel!(cache,f,x...)\n\nApplies the kernel f at the arguments x... using the scratch data provided in the given cache object. The cache object is built with the kernel_cache function using arguments of the same type as in x. In general, the returned value y can share some part of its state with the cache object. If the result of two or more invocations of this function need to be accessed simultaneously (e.g., in multi-threading), create and use various cache objects (e.g., one cache per thread).\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_cache-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_cache","text":"kernel_cache(f,x...)\n\nReturns the cache needed to apply kernel f with arguments of the same type as the objects in x. This function returns nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_return_type-Tuple{Any,Vararg{Any,N} where N}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_return_type","text":"kernel_return_type(f,x...)\n\nReturns the type of the result of calling kernel f with arguments of the types of the objects x.\n\nIt defaults to typeof(apply_kernel(f,x...))\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.test_kernel","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.test_kernel","text":"test_kernel(f,x::Tuple,y,cmp=(==))\n\nFunction used to test if the kernel f has been implemented correctly. f is a kernel object, x is a tuple containing the arguments  of the kernel, and y is the expected result. Function cmp is used to compare the computed result with the expected one. The checks are done with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Other-functions-using-kernels-1","page":"Gridap.Arrays","title":"Other functions using kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"apply_kernel\napply_kernels!\nkernel_caches\nkernel_return_types","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.apply_kernel","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_kernel","text":"apply_kernel(f,x...)\n\napply the kernel f at the arguments in x by creating a temporary cache internally. This functions is equivalent to\n\ncache = kernel_cache(f,x...)\napply_kernel!(cache,f,x...)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.apply_kernels!","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.apply_kernels!","text":"apply_kernels!(caches::Tuple,fs::Tuple,x...) -> Tuple\n\nApplies the kernels in the tuple fs at the arguments x... by using the corresponding cache objects in the tuple caches. The result is also a tuple containing the result for each kernel in fs.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_caches","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_caches","text":"kernel_caches(fs::Tuple,x...) -> Tuple\n\nReturns a tuple with the cache corresponding to each kernel in fs for the arguments x....\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.kernel_return_types","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.kernel_return_types","text":"kernel_return_types(f::Tuple,x...) -> Tuple\n\nComputes the return types of the kernels in f when called with arguments x.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Build-in-kernels-1","page":"Gridap.Arrays","title":"Build-in kernels","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"bcast\nelem\ncontract","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.bcast","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.bcast","text":"bcast(f::Function)\n\nReturns a kernel object that represents the \"boradcasted\" version of the given function f.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.elem","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.elem","text":"elem(f::Function)\n\nReturns a kernel that represents the element-wise version of the operation f It does not broadcast in singleton axes. Thus, allows some performance optimizations with respect to broadcast.\n\nwarning: Warning\nnot needed any more, to be deleted\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.contract","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.contract","text":"contract(f::Function)\n\nLike the dot product between to vectors, but using operation f instead of * between components.\n\nwarning: Warning\nnot needed any more, to be deleted\n\nExamples\n\nusing InplaceArrays.Arrays\nk = contract(-)\napply_kernel(k,[1,2],[2,4]) # Equivalent to (1-2) + (2-4)\n# output\n-3\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Concrete-array-implementations-1","page":"Gridap.Arrays","title":"Concrete array implementations","text":"","category":"section"},{"location":"Arrays/#CachedArray-1","page":"Gridap.Arrays","title":"CachedArray","text":"","category":"section"},{"location":"Arrays/#","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CachedArray\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\nsetsize!\nCachedMatrix\nCachedVector","category":"page"},{"location":"Arrays/#InplaceArrays.Arrays.CachedArray","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedArray","text":"mutable struct CachedArray{T, N, A<:AbstractArray{T,N}} <: AbstractArray{T,N}\n\nType providing a re-sizable array that only allocates memory when the underlying buffer needs to grow.\n\nThe size of a CachedArray is changed via the setsize! function.\n\nA CachedArray can be build with the constructors\n\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\n\nusing InplaceArrays.Arrays\n# Create an empty CachedArray\na = CachedArray(Float64,2)\n# Resize to new shape (2,3)\nsetsize!(a,(2,3))\nsize(a)\n# output\n(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.CachedArray-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedArray","text":"CachedArray(a::AbstractArray)\n\nConstructs a CachedArray from a given array.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.CachedArray-Tuple{Any,Any}","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedArray","text":"CachedArray(T,N)\n\nConstructs an empty CachedArray of element type T and N dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#InplaceArrays.Arrays.setsize!","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.setsize!","text":"setsize!(a, s)\n\n\nChanges the size of the CachedArray a to the size described the the tuple s. After calling setsize!, the array can store uninitialized values.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#InplaceArrays.Arrays.CachedMatrix","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedMatrix","text":"const CachedMatrix{T,A} = CachedArray{T,2,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#InplaceArrays.Arrays.CachedVector","page":"Gridap.Arrays","title":"InplaceArrays.Arrays.CachedVector","text":"const CachedVector{T,A} = CachedArray{T,1,A}\n\n\n\n\n\n","category":"type"},{"location":"Helpers/#","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"CurrentModule = InplaceArrays.Helpers","category":"page"},{"location":"Helpers/#Gridap.Helpers-1","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"","category":"section"},{"location":"Helpers/#","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"Modules = [Helpers,]","category":"page"},{"location":"Helpers/#InplaceArrays.Helpers","page":"Gridap.Helpers","title":"InplaceArrays.Helpers","text":"This module provides a set of helper macros and helper functions\n\nThe exported macros are:\n\n@abstractmethod\n@notimplemented\n@notimplementedif\ntfill\n@unreachable\n\n\n\n\n\n","category":"module"},{"location":"Helpers/#InplaceArrays.Helpers.tfill-Union{Tuple{D}, Tuple{Any,Val{D}}} where D","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.tfill","text":"tfill(v, ::Val{D}) where D\n\nReturns a tuple of length D that contains D times the object v. In contrast to tuple(fill(v,D)...) which returns the same result, this function is type-stable.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#InplaceArrays.Helpers.@abstractmethod-Tuple{}","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@abstractmethod","text":"@abstractmethod\n\nMacro used in generic functions that must be overloaded by derived types.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#InplaceArrays.Helpers.@notimplemented","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@notimplemented","text":"@notimplemented\n@notimplemented \"Error message\"\n\nMacro used to raise an error, when something is not implemented.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#InplaceArrays.Helpers.@notimplementedif","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@notimplementedif","text":"@notimplementedif condition\n@notimplementedif condition \"Error message\"\n\nMacro used to raise an error if the condition is true\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#InplaceArrays.Helpers.@unreachable","page":"Gridap.Helpers","title":"InplaceArrays.Helpers.@unreachable","text":"@unreachable\n@unreachable \"Error message\"\n\nMacro used to make sure that a line of code is never reached.\n\n\n\n\n\n","category":"macro"},{"location":"Polynomials/#","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"CurrentModule = InplaceArrays.Polynomials","category":"page"},{"location":"Polynomials/#Gridap.Polynomials-1","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"","category":"section"},{"location":"Polynomials/#","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"Modules = [Polynomials,]","category":"page"},{"location":"Polynomials/#InplaceArrays.Polynomials","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials","text":"This module provides a collection of multivariate polynomial bases.\n\nThe exported names are:\n\nMonomialBasis\nQCurlGradMonomialBasis\nQGradMonomialBasis\n\n\n\n\n\n","category":"module"},{"location":"Polynomials/#InplaceArrays.Polynomials.MonomialBasis","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.MonomialBasis","text":"struct MonomialBasis{...} <: Field\n\nType representing a basis of multivariate scalar-valued, vector-valued, or tensor-valued, iso- or aniso-tropic monomials. The type parameters and fields of this struct are not public, they are  private implementation details.   This type fully implements the Field interface, with up to second order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#InplaceArrays.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Function}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, order::Int [, filter::Function]) where {D,T}\n\nReturns an instance of MonomialBasis representing a multivariate polynomial basis in D dimensions, of polynomial degree order, whose value is represented by the type T. The type T is typically <:Number, e.g., Float64 for scalar-valued functions and VectorValue{D,Float64} for vector-valued ones.\n\nFilter function\n\nThe filter function is used to select which terms of the tensor product space of order order in D dimensions are to be used. If the filter is not provided, the full tensor-product space is used by default leading to a multivariate polynomial space of type Q. The signature of the filter function is\n\n(e,order) -> Bool\n\nwhere e is a tuple of D integers containing the exponents of a multivariate monomial. The following filters are used to select well known polynomial spaces\n\nQ space: (e,order) -> true\nP space: (e,order) -> sum(e) <= order\n\"Serendipity\" space: (e,order) -> sum( ( i for i in e if i>1 ) ) <= order\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#InplaceArrays.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Tuple{Vararg{Int64,D}}}, Tuple{Type{T},Tuple{Vararg{Int64,D}},Function}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, orders::Tuple [, filter::Function]) where {D,T}\n\nThis version of the constructor allows to pass a tuple orders containing the polynomial order to be used in each of the D dimensions in order to  construct and anisotropic tensor-product space.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#InplaceArrays.Polynomials.QCurlGradMonomialBasis","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QCurlGradMonomialBasis","text":"struct QCurlGradMonomialBasis{...} <: Field\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Raviart-Thomas reference elements on n-cubes. The type parameters and fields of this struct are not public.   This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#InplaceArrays.Polynomials.QCurlGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QCurlGradMonomialBasis","text":"QCurlGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QCurlGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#InplaceArrays.Polynomials.QGradMonomialBasis","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QGradMonomialBasis","text":"struct QGradMonomialBasis{...} <: Field\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Nedelec reference elements on n-cubes. The type parameters and fields of this struct are not public.   This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#InplaceArrays.Polynomials.QGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T},Int64}} where T where D","page":"Gridap.Polynomials","title":"InplaceArrays.Polynomials.QGradMonomialBasis","text":"QGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value.\n\n\n\n\n\n","category":"method"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"CurrentModule = InplaceArrays.TensorValues","category":"page"},{"location":"TensorValues/#Gridap.TensorValues-1","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"TensorValues","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues","text":"This module provides concrete implementations of Number that represent 1st, 2nd and general order tensors.\n\nWhy\n\nThe main feature of this module is that the provided types do not extend from AbstractArray, but from Number!\n\nThis allows one to work with them as if they were scalar values in broadcasted operations on arrays of VectorValue objects (also for TensorValue or MultiValue objects). For instance, one can perform the following manipulations:\n\n# Assing a VectorValue to all the entries of an Array of VectorValues\nA = zeros(VectorValue{2,Int}, (4,5))\nv = VectorValue(12,31)\nA .= v # This is posible since  VectorValue <: Number\n\n# Broatcasing of tensor operations in arrays of TensorValues\nt = TensorValue(13,41,53,17) # creates a 2x2 TensorValue\ng = TensorValue(32,41,3,14) # creates another 2x2 TensorValue\nB = fill(t,(1,5))\nC = inner.(g,B) # inner product of g against all TensorValues in the array B\n@show C\n# C = [2494 2494 2494 2494 2494]\n\nThe exported names are:\n\nMultiValue\nTensorValue\nVectorValue\ninner\nmeas\nmutable\nn_components\nouter\nsymmetic_part\n\n\n\n\n\n","category":"module"},{"location":"TensorValues/#Exported-types-1","page":"Gridap.TensorValues","title":"Exported types","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"MultiValue\nVectorValue\nTensorValue","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.MultiValue","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.MultiValue","text":"Type representing a multi-dimensional value\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#InplaceArrays.TensorValues.VectorValue","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.VectorValue","text":"Type representing a first-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#InplaceArrays.TensorValues.TensorValue","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.TensorValue","text":"Type representing a second-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Constructors-1","page":"Gridap.TensorValues","title":"Constructors","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"mutable","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.mutable","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.mutable","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#Info-getters-1","page":"Gridap.TensorValues","title":"Info getters","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"n_components","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.n_components","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.n_components","text":"n_components(::Type)\n\nReturns the number of components stored in the given type. Implemented for types <:Real and <:MultiValue. Also available for instances of these types.\n\n\n\n\n\n","category":"function"},{"location":"TensorValues/#Operations-1","page":"Gridap.TensorValues","title":"Operations","text":"","category":"section"},{"location":"TensorValues/#","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"inner\nouter\nmeas\nsymmetic_part","category":"page"},{"location":"TensorValues/#InplaceArrays.TensorValues.inner","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.inner","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#InplaceArrays.TensorValues.outer","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.outer","text":"\n\n\n\nouter(∇,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\nouter(f,∇)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n","category":"function"},{"location":"TensorValues/#InplaceArrays.TensorValues.meas","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.meas","text":"\n\n\n\n","category":"function"},{"location":"TensorValues/#InplaceArrays.TensorValues.symmetic_part","page":"Gridap.TensorValues","title":"InplaceArrays.TensorValues.symmetic_part","text":"\n\n\n\n","category":"function"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Documentation for Gridap.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n  \"index.md\",\n  \"Gridap.md\",\n  \"Helpers.md\",\n  \"Inference.md\",\n  \"TensorValues.md\",\n  \"Arrays.md\",\n  \"Fields.md\",\n  \"Polynomials.md\",\n  ]","category":"page"}]
}
